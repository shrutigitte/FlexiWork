"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dotenv";
exports.ids = ["vendor-chunks/dotenv"];
exports.modules = {

/***/ "(action-browser)/./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst packageJson = __webpack_require__(/*! ../package.json */ \"(action-browser)/./node_modules/dotenv/package.json\");\nconst version = packageJson.version;\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n// Parse src into an Object\nfunction parse(src) {\n    const obj = {};\n    // Convert buffer to string\n    let lines = src.toString();\n    // Convert line breaks to same format\n    lines = lines.replace(/\\r\\n?/mg, \"\\n\");\n    let match;\n    while((match = LINE.exec(lines)) != null){\n        const key = match[1];\n        // Default undefined or null to empty string\n        let value = match[2] || \"\";\n        // Remove whitespace\n        value = value.trim();\n        // Check if double quoted\n        const maybeQuote = value[0];\n        // Remove surrounding quotes\n        value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, \"$2\");\n        // Expand newlines if double quoted\n        if (maybeQuote === '\"') {\n            value = value.replace(/\\\\n/g, \"\\n\");\n            value = value.replace(/\\\\r/g, \"\\r\");\n        }\n        // Add to object\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _parseVault(options) {\n    const vaultPath = _vaultPath(options);\n    // Parse .env.vault\n    const result = DotenvModule.configDotenv({\n        path: vaultPath\n    });\n    if (!result.parsed) {\n        throw new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);\n    }\n    // handle scenario for comma separated keys - for use with key rotation\n    // example: DOTENV_KEY=\"dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenv.org/vault/.env.vault?environment=prod\"\n    const keys = _dotenvKey(options).split(\",\");\n    const length = keys.length;\n    let decrypted;\n    for(let i = 0; i < length; i++){\n        try {\n            // Get full key\n            const key = keys[i].trim();\n            // Get instructions for decrypt\n            const attrs = _instructions(result, key);\n            // Decrypt\n            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);\n            break;\n        } catch (error) {\n            // last key\n            if (i + 1 >= length) {\n                throw error;\n            }\n        // try next key\n        }\n    }\n    // Parse decrypted .env string\n    return DotenvModule.parse(decrypted);\n}\nfunction _log(message) {\n    console.log(`[dotenv@${version}][INFO] ${message}`);\n}\nfunction _warn(message) {\n    console.log(`[dotenv@${version}][WARN] ${message}`);\n}\nfunction _debug(message) {\n    console.log(`[dotenv@${version}][DEBUG] ${message}`);\n}\nfunction _dotenvKey(options) {\n    // prioritize developer directly setting options.DOTENV_KEY\n    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n        return options.DOTENV_KEY;\n    }\n    // secondary infra already contains a DOTENV_KEY environment variable\n    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n        return process.env.DOTENV_KEY;\n    }\n    // fallback to empty string\n    return \"\";\n}\nfunction _instructions(result, dotenvKey) {\n    // Parse DOTENV_KEY. Format is a URI\n    let uri;\n    try {\n        uri = new URL(dotenvKey);\n    } catch (error) {\n        if (error.code === \"ERR_INVALID_URL\") {\n            throw new Error(\"INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenv.org/vault/.env.vault?environment=development\");\n        }\n        throw error;\n    }\n    // Get decrypt key\n    const key = uri.password;\n    if (!key) {\n        throw new Error(\"INVALID_DOTENV_KEY: Missing key part\");\n    }\n    // Get environment\n    const environment = uri.searchParams.get(\"environment\");\n    if (!environment) {\n        throw new Error(\"INVALID_DOTENV_KEY: Missing environment part\");\n    }\n    // Get ciphertext payload\n    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;\n    const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n    ;\n    if (!ciphertext) {\n        throw new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);\n    }\n    return {\n        ciphertext,\n        key\n    };\n}\nfunction _vaultPath(options) {\n    let dotenvPath = path.resolve(process.cwd(), \".env\");\n    if (options && options.path && options.path.length > 0) {\n        dotenvPath = options.path;\n    }\n    // Locate .env.vault\n    return dotenvPath.endsWith(\".vault\") ? dotenvPath : `${dotenvPath}.vault`;\n}\nfunction _resolveHome(envPath) {\n    return envPath[0] === \"~\" ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\nfunction _configVault(options) {\n    _log(\"Loading env from encrypted .env.vault\");\n    const parsed = DotenvModule._parseVault(options);\n    let processEnv = process.env;\n    if (options && options.processEnv != null) {\n        processEnv = options.processEnv;\n    }\n    DotenvModule.populate(processEnv, parsed, options);\n    return {\n        parsed\n    };\n}\nfunction configDotenv(options) {\n    let dotenvPath = path.resolve(process.cwd(), \".env\");\n    let encoding = \"utf8\";\n    const debug = Boolean(options && options.debug);\n    if (options) {\n        if (options.path != null) {\n            dotenvPath = _resolveHome(options.path);\n        }\n        if (options.encoding != null) {\n            encoding = options.encoding;\n        }\n    }\n    try {\n        // Specifying an encoding returns a string instead of a buffer\n        const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, {\n            encoding\n        }));\n        let processEnv = process.env;\n        if (options && options.processEnv != null) {\n            processEnv = options.processEnv;\n        }\n        DotenvModule.populate(processEnv, parsed, options);\n        return {\n            parsed\n        };\n    } catch (e) {\n        if (debug) {\n            _debug(`Failed to load ${dotenvPath} ${e.message}`);\n        }\n        return {\n            error: e\n        };\n    }\n}\n// Populates process.env from .env file\nfunction config(options) {\n    const vaultPath = _vaultPath(options);\n    // fallback to original dotenv if DOTENV_KEY is not set\n    if (_dotenvKey(options).length === 0) {\n        return DotenvModule.configDotenv(options);\n    }\n    // dotenvKey exists but .env.vault file does not exist\n    if (!fs.existsSync(vaultPath)) {\n        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);\n        return DotenvModule.configDotenv(options);\n    }\n    return DotenvModule._configVault(options);\n}\nfunction decrypt(encrypted, keyStr) {\n    const key = Buffer.from(keyStr.slice(-64), \"hex\");\n    let ciphertext = Buffer.from(encrypted, \"base64\");\n    const nonce = ciphertext.slice(0, 12);\n    const authTag = ciphertext.slice(-16);\n    ciphertext = ciphertext.slice(12, -16);\n    try {\n        const aesgcm = crypto.createDecipheriv(\"aes-256-gcm\", key, nonce);\n        aesgcm.setAuthTag(authTag);\n        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;\n    } catch (error) {\n        const isRange = error instanceof RangeError;\n        const invalidKeyLength = error.message === \"Invalid key length\";\n        const decryptionFailed = error.message === \"Unsupported state or unable to authenticate data\";\n        if (isRange || invalidKeyLength) {\n            const msg = \"INVALID_DOTENV_KEY: It must be 64 characters long (or more)\";\n            throw new Error(msg);\n        } else if (decryptionFailed) {\n            const msg = \"DECRYPTION_FAILED: Please check your DOTENV_KEY\";\n            throw new Error(msg);\n        } else {\n            console.error(\"Error: \", error.code);\n            console.error(\"Error: \", error.message);\n            throw error;\n        }\n    }\n}\n// Populate process.env with parsed values\nfunction populate(processEnv, parsed, options = {}) {\n    const debug = Boolean(options && options.debug);\n    const override = Boolean(options && options.override);\n    if (typeof parsed !== \"object\") {\n        throw new Error(\"OBJECT_REQUIRED: Please check the processEnv argument being passed to populate\");\n    }\n    // Set process.env\n    for (const key of Object.keys(parsed)){\n        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n            if (override === true) {\n                processEnv[key] = parsed[key];\n            }\n            if (debug) {\n                if (override === true) {\n                    _debug(`\"${key}\" is already defined and WAS overwritten`);\n                } else {\n                    _debug(`\"${key}\" is already defined and was NOT overwritten`);\n                }\n            }\n        } else {\n            processEnv[key] = parsed[key];\n        }\n    }\n}\nconst DotenvModule = {\n    configDotenv,\n    _configVault,\n    _parseVault,\n    config,\n    decrypt,\n    parse,\n    populate\n};\nmodule.exports.configDotenv = DotenvModule.configDotenv;\nmodule.exports._configVault = DotenvModule._configVault;\nmodule.exports._parseVault = DotenvModule._parseVault;\nmodule.exports.config = DotenvModule.config;\nmodule.exports.decrypt = DotenvModule.decrypt;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports.populate = DotenvModule.populate;\nmodule.exports = DotenvModule;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kb3RlbnYvbGliL21haW4uanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLEtBQUtDLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU1FLEtBQUtGLG1CQUFPQSxDQUFDO0FBQ25CLE1BQU1HLFNBQVNILG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDO0FBRTVCLE1BQU1LLFVBQVVELFlBQVlDLE9BQU87QUFFbkMsTUFBTUMsT0FBTztBQUViLDJCQUEyQjtBQUMzQixTQUFTQyxNQUFPQyxHQUFHO0lBQ2pCLE1BQU1DLE1BQU0sQ0FBQztJQUViLDJCQUEyQjtJQUMzQixJQUFJQyxRQUFRRixJQUFJRyxRQUFRO0lBRXhCLHFDQUFxQztJQUNyQ0QsUUFBUUEsTUFBTUUsT0FBTyxDQUFDLFdBQVc7SUFFakMsSUFBSUM7SUFDSixNQUFPLENBQUNBLFFBQVFQLEtBQUtRLElBQUksQ0FBQ0osTUFBSyxLQUFNLEtBQU07UUFDekMsTUFBTUssTUFBTUYsS0FBSyxDQUFDLEVBQUU7UUFFcEIsNENBQTRDO1FBQzVDLElBQUlHLFFBQVNILEtBQUssQ0FBQyxFQUFFLElBQUk7UUFFekIsb0JBQW9CO1FBQ3BCRyxRQUFRQSxNQUFNQyxJQUFJO1FBRWxCLHlCQUF5QjtRQUN6QixNQUFNQyxhQUFhRixLQUFLLENBQUMsRUFBRTtRQUUzQiw0QkFBNEI7UUFDNUJBLFFBQVFBLE1BQU1KLE9BQU8sQ0FBQywwQkFBMEI7UUFFaEQsbUNBQW1DO1FBQ25DLElBQUlNLGVBQWUsS0FBSztZQUN0QkYsUUFBUUEsTUFBTUosT0FBTyxDQUFDLFFBQVE7WUFDOUJJLFFBQVFBLE1BQU1KLE9BQU8sQ0FBQyxRQUFRO1FBQ2hDO1FBRUEsZ0JBQWdCO1FBQ2hCSCxHQUFHLENBQUNNLElBQUksR0FBR0M7SUFDYjtJQUVBLE9BQU9QO0FBQ1Q7QUFFQSxTQUFTVSxZQUFhQyxPQUFP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RSxRQUFRO0lBRXBELElBQUksT0FBT25FLFdBQVcsVUFBVTtRQUM5QixNQUFNLElBQUlDLE1BQU07SUFDbEI7SUFFQSxrQkFBa0I7SUFDbEIsS0FBSyxNQUFNWixPQUFPK0UsT0FBT2xFLElBQUksQ0FBQ0YsUUFBUztRQUNyQyxJQUFJb0UsT0FBT0MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQzdCLFlBQVlyRCxNQUFNO1lBQ3pELElBQUk4RSxhQUFhLE1BQU07Z0JBQ3JCekIsVUFBVSxDQUFDckQsSUFBSSxHQUFHVyxNQUFNLENBQUNYLElBQUk7WUFDL0I7WUFFQSxJQUFJd0QsT0FBTztnQkFDVCxJQUFJc0IsYUFBYSxNQUFNO29CQUNyQmpELE9BQU8sQ0FBQyxDQUFDLEVBQUU3QixJQUFJLHdDQUF3QyxDQUFDO2dCQUMxRCxPQUFPO29CQUNMNkIsT0FBTyxDQUFDLENBQUMsRUFBRTdCLElBQUksNENBQTRDLENBQUM7Z0JBQzlEO1lBQ0Y7UUFDRixPQUFPO1lBQ0xxRCxVQUFVLENBQUNyRCxJQUFJLEdBQUdXLE1BQU0sQ0FBQ1gsSUFBSTtRQUMvQjtJQUNGO0FBQ0Y7QUFFQSxNQUFNUyxlQUFlO0lBQ25CQztJQUNBMEM7SUFDQWhEO0lBQ0F3RDtJQUNBdkM7SUFDQTdCO0lBQ0E4RDtBQUNGO0FBRUE2QiwyQkFBMkIsR0FBRzFFLGFBQWFDLFlBQVk7QUFDdkR5RSwyQkFBMkIsR0FBRzFFLGFBQWEyQyxZQUFZO0FBQ3ZEK0IsMEJBQTBCLEdBQUcxRSxhQUFhTCxXQUFXO0FBQ3JEK0UscUJBQXFCLEdBQUcxRSxhQUFhbUQsTUFBTTtBQUMzQ3VCLHNCQUFzQixHQUFHMUUsYUFBYVksT0FBTztBQUM3QzhELG9CQUFvQixHQUFHMUUsYUFBYWpCLEtBQUs7QUFDekMyRix1QkFBdUIsR0FBRzFFLGFBQWE2QyxRQUFRO0FBRS9DNkIsT0FBT0MsT0FBTyxHQUFHM0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy9kb3RlbnYvbGliL21haW4uanM/MmQ4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbmNvbnN0IHBhY2thZ2VKc29uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJylcblxuY29uc3QgdmVyc2lvbiA9IHBhY2thZ2VKc29uLnZlcnNpb25cblxuY29uc3QgTElORSA9IC8oPzpefF4pXFxzKig/OmV4cG9ydFxccyspPyhbXFx3Li1dKykoPzpcXHMqPVxccyo/fDpcXHMrPykoXFxzKicoPzpcXFxcJ3xbXiddKSonfFxccypcIig/OlxcXFxcInxbXlwiXSkqXCJ8XFxzKmAoPzpcXFxcYHxbXmBdKSpgfFteI1xcclxcbl0rKT9cXHMqKD86Iy4qKT8oPzokfCQpL21nXG5cbi8vIFBhcnNlIHNyYyBpbnRvIGFuIE9iamVjdFxuZnVuY3Rpb24gcGFyc2UgKHNyYykge1xuICBjb25zdCBvYmogPSB7fVxuXG4gIC8vIENvbnZlcnQgYnVmZmVyIHRvIHN0cmluZ1xuICBsZXQgbGluZXMgPSBzcmMudG9TdHJpbmcoKVxuXG4gIC8vIENvbnZlcnQgbGluZSBicmVha3MgdG8gc2FtZSBmb3JtYXRcbiAgbGluZXMgPSBsaW5lcy5yZXBsYWNlKC9cXHJcXG4/L21nLCAnXFxuJylcblxuICBsZXQgbWF0Y2hcbiAgd2hpbGUgKChtYXRjaCA9IExJTkUuZXhlYyhsaW5lcykpICE9IG51bGwpIHtcbiAgICBjb25zdCBrZXkgPSBtYXRjaFsxXVxuXG4gICAgLy8gRGVmYXVsdCB1bmRlZmluZWQgb3IgbnVsbCB0byBlbXB0eSBzdHJpbmdcbiAgICBsZXQgdmFsdWUgPSAobWF0Y2hbMl0gfHwgJycpXG5cbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZVxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgICAvLyBDaGVjayBpZiBkb3VibGUgcXVvdGVkXG4gICAgY29uc3QgbWF5YmVRdW90ZSA9IHZhbHVlWzBdXG5cbiAgICAvLyBSZW1vdmUgc3Vycm91bmRpbmcgcXVvdGVzXG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKFsnXCJgXSkoW1xcc1xcU10qKVxcMSQvbWcsICckMicpXG5cbiAgICAvLyBFeHBhbmQgbmV3bGluZXMgaWYgZG91YmxlIHF1b3RlZFxuICAgIGlmIChtYXliZVF1b3RlID09PSAnXCInKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcci9nLCAnXFxyJylcbiAgICB9XG5cbiAgICAvLyBBZGQgdG8gb2JqZWN0XG4gICAgb2JqW2tleV0gPSB2YWx1ZVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiBfcGFyc2VWYXVsdCAob3B0aW9ucykge1xuICBjb25zdCB2YXVsdFBhdGggPSBfdmF1bHRQYXRoKG9wdGlvbnMpXG5cbiAgLy8gUGFyc2UgLmVudi52YXVsdFxuICBjb25zdCByZXN1bHQgPSBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52KHsgcGF0aDogdmF1bHRQYXRoIH0pXG4gIGlmICghcmVzdWx0LnBhcnNlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTUlTU0lOR19EQVRBOiBDYW5ub3QgcGFyc2UgJHt2YXVsdFBhdGh9IGZvciBhbiB1bmtub3duIHJlYXNvbmApXG4gIH1cblxuICAvLyBoYW5kbGUgc2NlbmFyaW8gZm9yIGNvbW1hIHNlcGFyYXRlZCBrZXlzIC0gZm9yIHVzZSB3aXRoIGtleSByb3RhdGlvblxuICAvLyBleGFtcGxlOiBET1RFTlZfS0VZPVwiZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudi5vcmcvdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kLGRvdGVudjovLzprZXlfNzg5MEBkb3RlbnYub3JnL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9cHJvZFwiXG4gIGNvbnN0IGtleXMgPSBfZG90ZW52S2V5KG9wdGlvbnMpLnNwbGl0KCcsJylcbiAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGhcblxuICBsZXQgZGVjcnlwdGVkXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGZ1bGwga2V5XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldLnRyaW0oKVxuXG4gICAgICAvLyBHZXQgaW5zdHJ1Y3Rpb25zIGZvciBkZWNyeXB0XG4gICAgICBjb25zdCBhdHRycyA9IF9pbnN0cnVjdGlvbnMocmVzdWx0LCBrZXkpXG5cbiAgICAgIC8vIERlY3J5cHRcbiAgICAgIGRlY3J5cHRlZCA9IERvdGVudk1vZHVsZS5kZWNyeXB0KGF0dHJzLmNpcGhlcnRleHQsIGF0dHJzLmtleSlcblxuICAgICAgYnJlYWtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gbGFzdCBrZXlcbiAgICAgIGlmIChpICsgMSA+PSBsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICAgIC8vIHRyeSBuZXh0IGtleVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIGRlY3J5cHRlZCAuZW52IHN0cmluZ1xuICByZXR1cm4gRG90ZW52TW9kdWxlLnBhcnNlKGRlY3J5cHRlZClcbn1cblxuZnVuY3Rpb24gX2xvZyAobWVzc2FnZSkge1xuICBjb25zb2xlLmxvZyhgW2RvdGVudkAke3ZlcnNpb259XVtJTkZPXSAke21lc3NhZ2V9YClcbn1cblxuZnVuY3Rpb24gX3dhcm4gKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bV0FSTl0gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF9kZWJ1ZyAobWVzc2FnZSkge1xuICBjb25zb2xlLmxvZyhgW2RvdGVudkAke3ZlcnNpb259XVtERUJVR10gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF9kb3RlbnZLZXkgKG9wdGlvbnMpIHtcbiAgLy8gcHJpb3JpdGl6ZSBkZXZlbG9wZXIgZGlyZWN0bHkgc2V0dGluZyBvcHRpb25zLkRPVEVOVl9LRVlcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ET1RFTlZfS0VZICYmIG9wdGlvbnMuRE9URU5WX0tFWS5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuRE9URU5WX0tFWVxuICB9XG5cbiAgLy8gc2Vjb25kYXJ5IGluZnJhIGFscmVhZHkgY29udGFpbnMgYSBET1RFTlZfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlXG4gIGlmIChwcm9jZXNzLmVudi5ET1RFTlZfS0VZICYmIHByb2Nlc3MuZW52LkRPVEVOVl9LRVkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZXG4gIH1cblxuICAvLyBmYWxsYmFjayB0byBlbXB0eSBzdHJpbmdcbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIF9pbnN0cnVjdGlvbnMgKHJlc3VsdCwgZG90ZW52S2V5KSB7XG4gIC8vIFBhcnNlIERPVEVOVl9LRVkuIEZvcm1hdCBpcyBhIFVSSVxuICBsZXQgdXJpXG4gIHRyeSB7XG4gICAgdXJpID0gbmV3IFVSTChkb3RlbnZLZXkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09ICdFUlJfSU5WQUxJRF9VUkwnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogV3JvbmcgZm9ybWF0LiBNdXN0IGJlIGluIHZhbGlkIHVyaSBmb3JtYXQgbGlrZSBkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52Lm9yZy92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PWRldmVsb3BtZW50JylcbiAgICB9XG5cbiAgICB0aHJvdyBlcnJvclxuICB9XG5cbiAgLy8gR2V0IGRlY3J5cHQga2V5XG4gIGNvbnN0IGtleSA9IHVyaS5wYXNzd29yZFxuICBpZiAoIWtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGtleSBwYXJ0JylcbiAgfVxuXG4gIC8vIEdldCBlbnZpcm9ubWVudFxuICBjb25zdCBlbnZpcm9ubWVudCA9IHVyaS5zZWFyY2hQYXJhbXMuZ2V0KCdlbnZpcm9ubWVudCcpXG4gIGlmICghZW52aXJvbm1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogTWlzc2luZyBlbnZpcm9ubWVudCBwYXJ0JylcbiAgfVxuXG4gIC8vIEdldCBjaXBoZXJ0ZXh0IHBheWxvYWRcbiAgY29uc3QgZW52aXJvbm1lbnRLZXkgPSBgRE9URU5WX1ZBVUxUXyR7ZW52aXJvbm1lbnQudG9VcHBlckNhc2UoKX1gXG4gIGNvbnN0IGNpcGhlcnRleHQgPSByZXN1bHQucGFyc2VkW2Vudmlyb25tZW50S2V5XSAvLyBET1RFTlZfVkFVTFRfUFJPRFVDVElPTlxuICBpZiAoIWNpcGhlcnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5PVF9GT1VORF9ET1RFTlZfRU5WSVJPTk1FTlQ6IENhbm5vdCBsb2NhdGUgZW52aXJvbm1lbnQgJHtlbnZpcm9ubWVudEtleX0gaW4geW91ciAuZW52LnZhdWx0IGZpbGUuYClcbiAgfVxuXG4gIHJldHVybiB7IGNpcGhlcnRleHQsIGtleSB9XG59XG5cbmZ1bmN0aW9uIF92YXVsdFBhdGggKG9wdGlvbnMpIHtcbiAgbGV0IGRvdGVudlBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgJy5lbnYnKVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCAmJiBvcHRpb25zLnBhdGgubGVuZ3RoID4gMCkge1xuICAgIGRvdGVudlBhdGggPSBvcHRpb25zLnBhdGhcbiAgfVxuXG4gIC8vIExvY2F0ZSAuZW52LnZhdWx0XG4gIHJldHVybiBkb3RlbnZQYXRoLmVuZHNXaXRoKCcudmF1bHQnKSA/IGRvdGVudlBhdGggOiBgJHtkb3RlbnZQYXRofS52YXVsdGBcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVIb21lIChlbnZQYXRoKSB7XG4gIHJldHVybiBlbnZQYXRoWzBdID09PSAnficgPyBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCBlbnZQYXRoLnNsaWNlKDEpKSA6IGVudlBhdGhcbn1cblxuZnVuY3Rpb24gX2NvbmZpZ1ZhdWx0IChvcHRpb25zKSB7XG4gIF9sb2coJ0xvYWRpbmcgZW52IGZyb20gZW5jcnlwdGVkIC5lbnYudmF1bHQnKVxuXG4gIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5fcGFyc2VWYXVsdChvcHRpb25zKVxuXG4gIGxldCBwcm9jZXNzRW52ID0gcHJvY2Vzcy5lbnZcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wcm9jZXNzRW52ICE9IG51bGwpIHtcbiAgICBwcm9jZXNzRW52ID0gb3B0aW9ucy5wcm9jZXNzRW52XG4gIH1cblxuICBEb3RlbnZNb2R1bGUucG9wdWxhdGUocHJvY2Vzc0VudiwgcGFyc2VkLCBvcHRpb25zKVxuXG4gIHJldHVybiB7IHBhcnNlZCB9XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0RvdGVudiAob3B0aW9ucykge1xuICBsZXQgZG90ZW52UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLmVudicpXG4gIGxldCBlbmNvZGluZyA9ICd1dGY4J1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGF0aCAhPSBudWxsKSB7XG4gICAgICBkb3RlbnZQYXRoID0gX3Jlc29sdmVIb21lKG9wdGlvbnMucGF0aClcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgIT0gbnVsbCkge1xuICAgICAgZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBTcGVjaWZ5aW5nIGFuIGVuY29kaW5nIHJldHVybnMgYSBzdHJpbmcgaW5zdGVhZCBvZiBhIGJ1ZmZlclxuICAgIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZG90ZW52UGF0aCwgeyBlbmNvZGluZyB9KSlcblxuICAgIGxldCBwcm9jZXNzRW52ID0gcHJvY2Vzcy5lbnZcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICAgIH1cblxuICAgIERvdGVudk1vZHVsZS5wb3B1bGF0ZShwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMpXG5cbiAgICByZXR1cm4geyBwYXJzZWQgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICBfZGVidWcoYEZhaWxlZCB0byBsb2FkICR7ZG90ZW52UGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICB9XG5cbiAgICByZXR1cm4geyBlcnJvcjogZSB9XG4gIH1cbn1cblxuLy8gUG9wdWxhdGVzIHByb2Nlc3MuZW52IGZyb20gLmVudiBmaWxlXG5mdW5jdGlvbiBjb25maWcgKG9wdGlvbnMpIHtcbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIGZhbGxiYWNrIHRvIG9yaWdpbmFsIGRvdGVudiBpZiBET1RFTlZfS0VZIGlzIG5vdCBzZXRcbiAgaWYgKF9kb3RlbnZLZXkob3B0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIERvdGVudk1vZHVsZS5jb25maWdEb3RlbnYob3B0aW9ucylcbiAgfVxuXG4gIC8vIGRvdGVudktleSBleGlzdHMgYnV0IC5lbnYudmF1bHQgZmlsZSBkb2VzIG5vdCBleGlzdFxuICBpZiAoIWZzLmV4aXN0c1N5bmModmF1bHRQYXRoKSkge1xuICAgIF93YXJuKGBZb3Ugc2V0IERPVEVOVl9LRVkgYnV0IHlvdSBhcmUgbWlzc2luZyBhIC5lbnYudmF1bHQgZmlsZSBhdCAke3ZhdWx0UGF0aH0uIERpZCB5b3UgZm9yZ2V0IHRvIGJ1aWxkIGl0P2ApXG5cbiAgICByZXR1cm4gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudihvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIERvdGVudk1vZHVsZS5fY29uZmlnVmF1bHQob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gZGVjcnlwdCAoZW5jcnlwdGVkLCBrZXlTdHIpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oa2V5U3RyLnNsaWNlKC02NCksICdoZXgnKVxuICBsZXQgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRlZCwgJ2Jhc2U2NCcpXG5cbiAgY29uc3Qgbm9uY2UgPSBjaXBoZXJ0ZXh0LnNsaWNlKDAsIDEyKVxuICBjb25zdCBhdXRoVGFnID0gY2lwaGVydGV4dC5zbGljZSgtMTYpXG4gIGNpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0LnNsaWNlKDEyLCAtMTYpXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBhZXNnY20gPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTI1Ni1nY20nLCBrZXksIG5vbmNlKVxuICAgIGFlc2djbS5zZXRBdXRoVGFnKGF1dGhUYWcpXG4gICAgcmV0dXJuIGAke2Flc2djbS51cGRhdGUoY2lwaGVydGV4dCl9JHthZXNnY20uZmluYWwoKX1gXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaXNSYW5nZSA9IGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvclxuICAgIGNvbnN0IGludmFsaWRLZXlMZW5ndGggPSBlcnJvci5tZXNzYWdlID09PSAnSW52YWxpZCBrZXkgbGVuZ3RoJ1xuICAgIGNvbnN0IGRlY3J5cHRpb25GYWlsZWQgPSBlcnJvci5tZXNzYWdlID09PSAnVW5zdXBwb3J0ZWQgc3RhdGUgb3IgdW5hYmxlIHRvIGF1dGhlbnRpY2F0ZSBkYXRhJ1xuXG4gICAgaWYgKGlzUmFuZ2UgfHwgaW52YWxpZEtleUxlbmd0aCkge1xuICAgICAgY29uc3QgbXNnID0gJ0lOVkFMSURfRE9URU5WX0tFWTogSXQgbXVzdCBiZSA2NCBjaGFyYWN0ZXJzIGxvbmcgKG9yIG1vcmUpJ1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICB9IGVsc2UgaWYgKGRlY3J5cHRpb25GYWlsZWQpIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdERUNSWVBUSU9OX0ZBSUxFRDogUGxlYXNlIGNoZWNrIHlvdXIgRE9URU5WX0tFWSdcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiAnLCBlcnJvci5jb2RlKVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6ICcsIGVycm9yLm1lc3NhZ2UpXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuXG4vLyBQb3B1bGF0ZSBwcm9jZXNzLmVudiB3aXRoIHBhcnNlZCB2YWx1ZXNcbmZ1bmN0aW9uIHBvcHVsYXRlIChwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuICBjb25zdCBvdmVycmlkZSA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJyaWRlKVxuXG4gIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignT0JKRUNUX1JFUVVJUkVEOiBQbGVhc2UgY2hlY2sgdGhlIHByb2Nlc3NFbnYgYXJndW1lbnQgYmVpbmcgcGFzc2VkIHRvIHBvcHVsYXRlJylcbiAgfVxuXG4gIC8vIFNldCBwcm9jZXNzLmVudlxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJzZWQpKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm9jZXNzRW52LCBrZXkpKSB7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcbiAgICAgICAgcHJvY2Vzc0VudltrZXldID0gcGFyc2VkW2tleV1cbiAgICAgIH1cblxuICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF9kZWJ1ZyhgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYW5kIFdBUyBvdmVyd3JpdHRlbmApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2RlYnVnKGBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgd2FzIE5PVCBvdmVyd3JpdHRlbmApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzc0VudltrZXldID0gcGFyc2VkW2tleV1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgRG90ZW52TW9kdWxlID0ge1xuICBjb25maWdEb3RlbnYsXG4gIF9jb25maWdWYXVsdCxcbiAgX3BhcnNlVmF1bHQsXG4gIGNvbmZpZyxcbiAgZGVjcnlwdCxcbiAgcGFyc2UsXG4gIHBvcHVsYXRlXG59XG5cbm1vZHVsZS5leHBvcnRzLmNvbmZpZ0RvdGVudiA9IERvdGVudk1vZHVsZS5jb25maWdEb3RlbnZcbm1vZHVsZS5leHBvcnRzLl9jb25maWdWYXVsdCA9IERvdGVudk1vZHVsZS5fY29uZmlnVmF1bHRcbm1vZHVsZS5leHBvcnRzLl9wYXJzZVZhdWx0ID0gRG90ZW52TW9kdWxlLl9wYXJzZVZhdWx0XG5tb2R1bGUuZXhwb3J0cy5jb25maWcgPSBEb3RlbnZNb2R1bGUuY29uZmlnXG5tb2R1bGUuZXhwb3J0cy5kZWNyeXB0ID0gRG90ZW52TW9kdWxlLmRlY3J5cHRcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gRG90ZW52TW9kdWxlLnBhcnNlXG5tb2R1bGUuZXhwb3J0cy5wb3B1bGF0ZSA9IERvdGVudk1vZHVsZS5wb3B1bGF0ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IERvdGVudk1vZHVsZVxuIl0sIm5hbWVzIjpbImZzIiwicmVxdWlyZSIsInBhdGgiLCJvcyIsImNyeXB0byIsInBhY2thZ2VKc29uIiwidmVyc2lvbiIsIkxJTkUiLCJwYXJzZSIsInNyYyIsIm9iaiIsImxpbmVzIiwidG9TdHJpbmciLCJyZXBsYWNlIiwibWF0Y2giLCJleGVjIiwia2V5IiwidmFsdWUiLCJ0cmltIiwibWF5YmVRdW90ZSIsIl9wYXJzZVZhdWx0Iiwib3B0aW9ucyIsInZhdWx0UGF0aCIsIl92YXVsdFBhdGgiLCJyZXN1bHQiLCJEb3RlbnZNb2R1bGUiLCJjb25maWdEb3RlbnYiLCJwYXJzZWQiLCJFcnJvciIsImtleXMiLCJfZG90ZW52S2V5Iiwic3BsaXQiLCJsZW5ndGgiLCJkZWNyeXB0ZWQiLCJpIiwiYXR0cnMiLCJfaW5zdHJ1Y3Rpb25zIiwiZGVjcnlwdCIsImNpcGhlcnRleHQiLCJlcnJvciIsIl9sb2ciLCJtZXNzYWdlIiwiY29uc29sZSIsImxvZyIsIl93YXJuIiwiX2RlYnVnIiwiRE9URU5WX0tFWSIsInByb2Nlc3MiLCJlbnYiLCJkb3RlbnZLZXkiLCJ1cmkiLCJVUkwiLCJjb2RlIiwicGFzc3dvcmQiLCJlbnZpcm9ubWVudCIsInNlYXJjaFBhcmFtcyIsImdldCIsImVudmlyb25tZW50S2V5IiwidG9VcHBlckNhc2UiLCJkb3RlbnZQYXRoIiwicmVzb2x2ZSIsImN3ZCIsImVuZHNXaXRoIiwiX3Jlc29sdmVIb21lIiwiZW52UGF0aCIsImpvaW4iLCJob21lZGlyIiwic2xpY2UiLCJfY29uZmlnVmF1bHQiLCJwcm9jZXNzRW52IiwicG9wdWxhdGUiLCJlbmNvZGluZyIsImRlYnVnIiwiQm9vbGVhbiIsInJlYWRGaWxlU3luYyIsImUiLCJjb25maWciLCJleGlzdHNTeW5jIiwiZW5jcnlwdGVkIiwia2V5U3RyIiwiQnVmZmVyIiwiZnJvbSIsIm5vbmNlIiwiYXV0aFRhZyIsImFlc2djbSIsImNyZWF0ZURlY2lwaGVyaXYiLCJzZXRBdXRoVGFnIiwidXBkYXRlIiwiZmluYWwiLCJpc1JhbmdlIiwiUmFuZ2VFcnJvciIsImludmFsaWRLZXlMZW5ndGgiLCJkZWNyeXB0aW9uRmFpbGVkIiwibXNnIiwib3ZlcnJpZGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/dotenv/lib/main.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/dotenv/package.json":
/*!******************************************!*\
  !*** ./node_modules/dotenv/package.json ***!
  \******************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"dotenv","version":"16.3.1","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","lint-readme":"standard-markdown","pretest":"npm run lint && npm run dts-check","test":"tap tests/*.js --100 -Rspec","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"funding":"https://github.com/motdotla/dotenv?sponsor=1","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@definitelytyped/dtslint":"^0.0.133","@types/node":"^18.11.3","decache":"^4.6.1","sinon":"^14.0.1","standard":"^17.0.0","standard-markdown":"^7.1.0","standard-version":"^9.5.0","tap":"^16.3.0","tar":"^6.1.11","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}');

/***/ })

};
;