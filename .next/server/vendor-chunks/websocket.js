/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/websocket";
exports.ids = ["vendor-chunks/websocket"];
exports.modules = {

/***/ "(ssr)/./node_modules/websocket/index.js":
/*!*****************************************!*\
  !*** ./node_modules/websocket/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/websocket */ \"(ssr)/./node_modules/websocket/lib/websocket.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLDhHQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnByb2RpZ2llcy1jeXByZXNzLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9pbmRleC5qcz9lMDA3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvd2Vic29ja2V0Jyk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/Deprecation.js":
/*!***************************************************!*\
  !*** ./node_modules/websocket/lib/Deprecation.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar Deprecation = {\n    disableWarnings: false,\n\n    deprecationWarningMap: {\n\n    },\n\n    warn: function(deprecationName) {\n        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {\n            console.warn('DEPRECATION WARNING: ' + this.deprecationWarningMap[deprecationName]);\n            this.deprecationWarningMap[deprecationName] = false;\n        }\n    }\n};\n\nmodule.exports = Deprecation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9EZXByZWNhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicHJvZGlnaWVzLWN5cHJlc3MvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9EZXByZWNhdGlvbi5qcz8yMDdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIERlcHJlY2F0aW9uID0ge1xuICAgIGRpc2FibGVXYXJuaW5nczogZmFsc2UsXG5cbiAgICBkZXByZWNhdGlvbldhcm5pbmdNYXA6IHtcblxuICAgIH0sXG5cbiAgICB3YXJuOiBmdW5jdGlvbihkZXByZWNhdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVXYXJuaW5ncyAmJiB0aGlzLmRlcHJlY2F0aW9uV2FybmluZ01hcFtkZXByZWNhdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6ICcgKyB0aGlzLmRlcHJlY2F0aW9uV2FybmluZ01hcFtkZXByZWNhdGlvbk5hbWVdKTtcbiAgICAgICAgICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5nTWFwW2RlcHJlY2F0aW9uTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVwcmVjYXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/Deprecation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/W3CWebSocket.js":
/*!****************************************************!*\
  !*** ./node_modules/websocket/lib/W3CWebSocket.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar WebSocketClient = __webpack_require__(/*! ./WebSocketClient */ \"(ssr)/./node_modules/websocket/lib/WebSocketClient.js\");\nvar toBuffer = __webpack_require__(/*! typedarray-to-buffer */ \"(ssr)/./node_modules/typedarray-to-buffer/index.js\");\nvar yaeti = __webpack_require__(/*! yaeti */ \"(ssr)/./node_modules/yaeti/index.js\");\n\n\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\n\n\nmodule.exports = W3CWebSocket;\n\n\nfunction W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {\n    // Make this an EventTarget.\n    yaeti.EventTarget.call(this);\n\n    // Sanitize clientConfig.\n    clientConfig = clientConfig || {};\n    clientConfig.assembleFragments = true;  // Required in the W3C API.\n\n    var self = this;\n\n    this._url = url;\n    this._readyState = CONNECTING;\n    this._protocol = undefined;\n    this._extensions = '';\n    this._bufferedAmount = 0;  // Hack, always 0.\n    this._binaryType = 'arraybuffer';  // TODO: Should be 'blob' by default, but Node has no Blob.\n\n    // The WebSocketConnection instance.\n    this._connection = undefined;\n\n    // WebSocketClient instance.\n    this._client = new WebSocketClient(clientConfig);\n\n    this._client.on('connect', function(connection) {\n        onConnect.call(self, connection);\n    });\n\n    this._client.on('connectFailed', function() {\n        onConnectFailed.call(self);\n    });\n\n    this._client.connect(url, protocols, origin, headers, requestOptions);\n}\n\n\n// Expose W3C read only attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    url:            { get: function() { return this._url;            } },\n    readyState:     { get: function() { return this._readyState;     } },\n    protocol:       { get: function() { return this._protocol;       } },\n    extensions:     { get: function() { return this._extensions;     } },\n    bufferedAmount: { get: function() { return this._bufferedAmount; } }\n});\n\n\n// Expose W3C write/read attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    binaryType: {\n        get: function() {\n            return this._binaryType;\n        },\n        set: function(type) {\n            // TODO: Just 'arraybuffer' supported.\n            if (type !== 'arraybuffer') {\n                throw new SyntaxError('just \"arraybuffer\" type allowed for \"binaryType\" attribute');\n            }\n            this._binaryType = type;\n        }\n    }\n});\n\n\n// Expose W3C readyState constants into the WebSocket instance as W3C states.\n[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket.prototype, property[0], {\n        get: function() { return property[1]; }\n    });\n});\n\n// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,\n// but there are so many libs relying on them).\n[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket, property[0], {\n        get: function() { return property[1]; }\n    });\n});\n\n\nW3CWebSocket.prototype.send = function(data) {\n    if (this._readyState !== OPEN) {\n        throw new Error('cannot call send() while not connected');\n    }\n\n    // Text.\n    if (typeof data === 'string' || data instanceof String) {\n        this._connection.sendUTF(data);\n    }\n    // Binary.\n    else {\n        // Node Buffer.\n        if (data instanceof Buffer) {\n            this._connection.sendBytes(data);\n        }\n        // If ArrayBuffer or ArrayBufferView convert it to Node Buffer.\n        else if (data.byteLength || data.byteLength === 0) {\n            data = toBuffer(data);\n            this._connection.sendBytes(data);\n        }\n        else {\n            throw new Error('unknown binary data:', data);\n        }\n    }\n};\n\n\nW3CWebSocket.prototype.close = function(code, reason) {\n    switch(this._readyState) {\n        case CONNECTING:\n            // NOTE: We don't have the WebSocketConnection instance yet so no\n            // way to close the TCP connection.\n            // Artificially invoke the onConnectFailed event.\n            onConnectFailed.call(this);\n            // And close if it connects after a while.\n            this._client.on('connect', function(connection) {\n                if (code) {\n                    connection.close(code, reason);\n                } else {\n                    connection.close();\n                }\n            });\n            break;\n        case OPEN:\n            this._readyState = CLOSING;\n            if (code) {\n                this._connection.close(code, reason);\n            } else {\n                this._connection.close();\n            }\n            break;\n        case CLOSING:\n        case CLOSED:\n            break;\n    }\n};\n\n\n/**\n * Private API.\n */\n\n\nfunction createCloseEvent(code, reason) {\n    var event = new yaeti.Event('close');\n\n    event.code = code;\n    event.reason = reason;\n    event.wasClean = (typeof code === 'undefined' || code === 1000);\n\n    return event;\n}\n\n\nfunction createMessageEvent(data) {\n    var event = new yaeti.Event('message');\n\n    event.data = data;\n\n    return event;\n}\n\n\nfunction onConnect(connection) {\n    var self = this;\n\n    this._readyState = OPEN;\n    this._connection = connection;\n    this._protocol = connection.protocol;\n    this._extensions = connection.extensions;\n\n    this._connection.on('close', function(code, reason) {\n        onClose.call(self, code, reason);\n    });\n\n    this._connection.on('message', function(msg) {\n        onMessage.call(self, msg);\n    });\n\n    this.dispatchEvent(new yaeti.Event('open'));\n}\n\n\nfunction onConnectFailed() {\n    destroy.call(this);\n    this._readyState = CLOSED;\n\n    try {\n        this.dispatchEvent(new yaeti.Event('error'));\n    } finally {\n        this.dispatchEvent(createCloseEvent(1006, 'connection failed'));\n    }\n}\n\n\nfunction onClose(code, reason) {\n    destroy.call(this);\n    this._readyState = CLOSED;\n\n    this.dispatchEvent(createCloseEvent(code, reason || ''));\n}\n\n\nfunction onMessage(message) {\n    if (message.utf8Data) {\n        this.dispatchEvent(createMessageEvent(message.utf8Data));\n    }\n    else if (message.binaryData) {\n        // Must convert from Node Buffer to ArrayBuffer.\n        // TODO: or to a Blob (which does not exist in Node!).\n        if (this.binaryType === 'arraybuffer') {\n            var buffer = message.binaryData;\n            var arraybuffer = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(arraybuffer);\n            for (var i=0, len=buffer.length; i<len; ++i) {\n                view[i] = buffer[i];\n            }\n            this.dispatchEvent(createMessageEvent(arraybuffer));\n        }\n    }\n}\n\n\nfunction destroy() {\n    this._client.removeAllListeners();\n    if (this._connection) {\n        this._connection.removeAllListeners();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XM0NXZWJTb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBTyxDQUFDLGdGQUFtQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsZ0ZBQXNCO0FBQzdDLFlBQVksbUJBQU8sQ0FBQyxrREFBTzs7O0FBRzNCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCLGdDQUFnQztBQUN4RSxzQkFBc0Isa0JBQWtCLGdDQUFnQztBQUN4RSxzQkFBc0Isa0JBQWtCLGdDQUFnQztBQUN4RSxzQkFBc0Isa0JBQWtCLGdDQUFnQztBQUN4RSxzQkFBc0Isa0JBQWtCO0FBQ3hDLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixLQUFLO0FBQ0wsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicHJvZGlnaWVzLWN5cHJlc3MvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XM0NXZWJTb2NrZXQuanM/ZWFhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBXZWJTb2NrZXRDbGllbnQgPSByZXF1aXJlKCcuL1dlYlNvY2tldENsaWVudCcpO1xudmFyIHRvQnVmZmVyID0gcmVxdWlyZSgndHlwZWRhcnJheS10by1idWZmZXInKTtcbnZhciB5YWV0aSA9IHJlcXVpcmUoJ3lhZXRpJyk7XG5cblxuY29uc3QgQ09OTkVDVElORyA9IDA7XG5jb25zdCBPUEVOID0gMTtcbmNvbnN0IENMT1NJTkcgPSAyO1xuY29uc3QgQ0xPU0VEID0gMztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFczQ1dlYlNvY2tldDtcblxuXG5mdW5jdGlvbiBXM0NXZWJTb2NrZXQodXJsLCBwcm90b2NvbHMsIG9yaWdpbiwgaGVhZGVycywgcmVxdWVzdE9wdGlvbnMsIGNsaWVudENvbmZpZykge1xuICAgIC8vIE1ha2UgdGhpcyBhbiBFdmVudFRhcmdldC5cbiAgICB5YWV0aS5FdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gICAgLy8gU2FuaXRpemUgY2xpZW50Q29uZmlnLlxuICAgIGNsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZyB8fCB7fTtcbiAgICBjbGllbnRDb25maWcuYXNzZW1ibGVGcmFnbWVudHMgPSB0cnVlOyAgLy8gUmVxdWlyZWQgaW4gdGhlIFczQyBBUEkuXG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9ICcnO1xuICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDsgIC8vIEhhY2ssIGFsd2F5cyAwLlxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInOyAgLy8gVE9ETzogU2hvdWxkIGJlICdibG9iJyBieSBkZWZhdWx0LCBidXQgTm9kZSBoYXMgbm8gQmxvYi5cblxuICAgIC8vIFRoZSBXZWJTb2NrZXRDb25uZWN0aW9uIGluc3RhbmNlLlxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBXZWJTb2NrZXRDbGllbnQgaW5zdGFuY2UuXG4gICAgdGhpcy5fY2xpZW50ID0gbmV3IFdlYlNvY2tldENsaWVudChjbGllbnRDb25maWcpO1xuXG4gICAgdGhpcy5fY2xpZW50Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBvbkNvbm5lY3QuY2FsbChzZWxmLCBjb25uZWN0aW9uKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsaWVudC5vbignY29ubmVjdEZhaWxlZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBvbkNvbm5lY3RGYWlsZWQuY2FsbChzZWxmKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2NsaWVudC5jb25uZWN0KHVybCwgcHJvdG9jb2xzLCBvcmlnaW4sIGhlYWRlcnMsIHJlcXVlc3RPcHRpb25zKTtcbn1cblxuXG4vLyBFeHBvc2UgVzNDIHJlYWQgb25seSBhdHRyaWJ1dGVzLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVzNDV2ViU29ja2V0LnByb3RvdHlwZSwge1xuICAgIHVybDogICAgICAgICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl91cmw7ICAgICAgICAgICAgfSB9LFxuICAgIHJlYWR5U3RhdGU6ICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9yZWFkeVN0YXRlOyAgICAgfSB9LFxuICAgIHByb3RvY29sOiAgICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9wcm90b2NvbDsgICAgICAgfSB9LFxuICAgIGV4dGVuc2lvbnM6ICAgICB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9leHRlbnNpb25zOyAgICAgfSB9LFxuICAgIGJ1ZmZlcmVkQW1vdW50OiB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDsgfSB9XG59KTtcblxuXG4vLyBFeHBvc2UgVzNDIHdyaXRlL3JlYWQgYXR0cmlidXRlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFczQ1dlYlNvY2tldC5wcm90b3R5cGUsIHtcbiAgICBiaW5hcnlUeXBlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBKdXN0ICdhcnJheWJ1ZmZlcicgc3VwcG9ydGVkLlxuICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ2p1c3QgXCJhcnJheWJ1ZmZlclwiIHR5cGUgYWxsb3dlZCBmb3IgXCJiaW5hcnlUeXBlXCIgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbi8vIEV4cG9zZSBXM0MgcmVhZHlTdGF0ZSBjb25zdGFudHMgaW50byB0aGUgV2ViU29ja2V0IGluc3RhbmNlIGFzIFczQyBzdGF0ZXMuXG5bWydDT05ORUNUSU5HJyxDT05ORUNUSU5HXSwgWydPUEVOJyxPUEVOXSwgWydDTE9TSU5HJyxDTE9TSU5HXSwgWydDTE9TRUQnLENMT1NFRF1dLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHlbMF0sIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHByb3BlcnR5WzFdOyB9XG4gICAgfSk7XG59KTtcblxuLy8gQWxzbyBleHBvc2UgVzNDIHJlYWR5U3RhdGUgY29uc3RhbnRzIGludG8gdGhlIFdlYlNvY2tldCBjbGFzcyAobm90IGRlZmluZWQgYnkgdGhlIFczQyxcbi8vIGJ1dCB0aGVyZSBhcmUgc28gbWFueSBsaWJzIHJlbHlpbmcgb24gdGhlbSkuXG5bWydDT05ORUNUSU5HJyxDT05ORUNUSU5HXSwgWydPUEVOJyxPUEVOXSwgWydDTE9TSU5HJyxDTE9TSU5HXSwgWydDTE9TRUQnLENMT1NFRF1dLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LCBwcm9wZXJ0eVswXSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvcGVydHlbMV07IH1cbiAgICB9KTtcbn0pO1xuXG5cblczQ1dlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gT1BFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjYWxsIHNlbmQoKSB3aGlsZSBub3QgY29ubmVjdGVkJyk7XG4gICAgfVxuXG4gICAgLy8gVGV4dC5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnIHx8IGRhdGEgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kVVRGKGRhdGEpO1xuICAgIH1cbiAgICAvLyBCaW5hcnkuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vZGUgQnVmZmVyLlxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kQnl0ZXMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3IGNvbnZlcnQgaXQgdG8gTm9kZSBCdWZmZXIuXG4gICAgICAgIGVsc2UgaWYgKGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uc2VuZEJ5dGVzKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJpbmFyeSBkYXRhOicsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5XM0NXZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgc3dpdGNoKHRoaXMuX3JlYWR5U3RhdGUpIHtcbiAgICAgICAgY2FzZSBDT05ORUNUSU5HOlxuICAgICAgICAgICAgLy8gTk9URTogV2UgZG9uJ3QgaGF2ZSB0aGUgV2ViU29ja2V0Q29ubmVjdGlvbiBpbnN0YW5jZSB5ZXQgc28gbm9cbiAgICAgICAgICAgIC8vIHdheSB0byBjbG9zZSB0aGUgVENQIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAvLyBBcnRpZmljaWFsbHkgaW52b2tlIHRoZSBvbkNvbm5lY3RGYWlsZWQgZXZlbnQuXG4gICAgICAgICAgICBvbkNvbm5lY3RGYWlsZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8vIEFuZCBjbG9zZSBpZiBpdCBjb25uZWN0cyBhZnRlciBhIHdoaWxlLlxuICAgICAgICAgICAgdGhpcy5fY2xpZW50Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUEVOOlxuICAgICAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IENMT1NJTkc7XG4gICAgICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24uY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ0xPU0lORzpcbiAgICAgICAgY2FzZSBDTE9TRUQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5cbi8qKlxuICogUHJpdmF0ZSBBUEkuXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVDbG9zZUV2ZW50KGNvZGUsIHJlYXNvbikge1xuICAgIHZhciBldmVudCA9IG5ldyB5YWV0aS5FdmVudCgnY2xvc2UnKTtcblxuICAgIGV2ZW50LmNvZGUgPSBjb2RlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC53YXNDbGVhbiA9ICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY29kZSA9PT0gMTAwMCk7XG5cbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cblxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgeWFldGkuRXZlbnQoJ21lc3NhZ2UnKTtcblxuICAgIGV2ZW50LmRhdGEgPSBkYXRhO1xuXG4gICAgcmV0dXJuIGV2ZW50O1xufVxuXG5cbmZ1bmN0aW9uIG9uQ29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IE9QRU47XG4gICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5fcHJvdG9jb2wgPSBjb25uZWN0aW9uLnByb3RvY29sO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBjb25uZWN0aW9uLmV4dGVuc2lvbnM7XG5cbiAgICB0aGlzLl9jb25uZWN0aW9uLm9uKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgICAgICBvbkNsb3NlLmNhbGwoc2VsZiwgY29kZSwgcmVhc29uKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgb25NZXNzYWdlLmNhbGwoc2VsZiwgbXNnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgeWFldGkuRXZlbnQoJ29wZW4nKSk7XG59XG5cblxuZnVuY3Rpb24gb25Db25uZWN0RmFpbGVkKCkge1xuICAgIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gQ0xPU0VEO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyB5YWV0aS5FdmVudCgnZXJyb3InKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUNsb3NlRXZlbnQoMTAwNiwgJ2Nvbm5lY3Rpb24gZmFpbGVkJykpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBvbkNsb3NlKGNvZGUsIHJlYXNvbikge1xuICAgIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gQ0xPU0VEO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUNsb3NlRXZlbnQoY29kZSwgcmVhc29uIHx8ICcnKSk7XG59XG5cblxuZnVuY3Rpb24gb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZS51dGY4RGF0YSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlTWVzc2FnZUV2ZW50KG1lc3NhZ2UudXRmOERhdGEpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWVzc2FnZS5iaW5hcnlEYXRhKSB7XG4gICAgICAgIC8vIE11c3QgY29udmVydCBmcm9tIE5vZGUgQnVmZmVyIHRvIEFycmF5QnVmZmVyLlxuICAgICAgICAvLyBUT0RPOiBvciB0byBhIEJsb2IgKHdoaWNoIGRvZXMgbm90IGV4aXN0IGluIE5vZGUhKS5cbiAgICAgICAgaWYgKHRoaXMuYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG1lc3NhZ2UuYmluYXJ5RGF0YTtcbiAgICAgICAgICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49YnVmZmVyLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoY3JlYXRlTWVzc2FnZUV2ZW50KGFycmF5YnVmZmVyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jbGllbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/W3CWebSocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketClient.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketClient.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\");\nvar extend = utils.extend;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(ssr)/./node_modules/websocket/lib/WebSocketConnection.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\n\nvar protocolSeparators = [\n    '(', ')', '<', '>', '@',\n    ',', ';', ':', '\\\\', '\\\"',\n    '/', '[', ']', '?', '=',\n    '{', '}', ' ', String.fromCharCode(9)\n];\n\nvar excludedTlsOptions = ['hostname','port','method','path','headers'];\n\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    // TODO: Implement extensions\n\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n          tlsOptions = config.tlsOptions;\n          delete config.tlsOptions;\n        }\n        else {\n          tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n\n    this._req = null;\n    \n    switch (this.config.webSocketVersion) {\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');\n    }\n}\n\nutil.inherits(WebSocketClient, EventEmitter);\n\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    \n    if (typeof(protocols) === 'string') {\n        if (protocols.length > 0) {\n            protocols = [protocols];\n        }\n        else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n\n    if (typeof(requestUrl) === 'string') {\n        this.url = url.parse(requestUrl);\n    }\n    else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error('You must specify a full WebSocket URL, including protocol.');\n    }\n    if (!this.url.host) {\n        throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');\n    }\n\n    this.secure = (this.url.protocol === 'wss:');\n\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for (var i=0; i < protocol.length; i ++) {\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n\n    var defaultPorts = {\n        'ws:': '80',\n        'wss:': '443'\n    };\n\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n\n    var nonce = bufferAllocUnsafe(16);\n    for (var i=0; i < 16; i++) {\n        nonce[i] = Math.round(Math.random()*0xFF);\n    }\n    this.base64nonce = nonce.toString('base64');\n\n    var hostHeaderValue = this.url.hostname;\n    if ((this.url.protocol === 'ws:' && this.url.port !== '80') ||\n        (this.url.protocol === 'wss:' && this.url.port !== '443'))  {\n        hostHeaderValue += (':' + this.url.port);\n    }\n\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {\n      // Allow for additional headers to be provided when connecting via HTTPS\n      extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n      // Explicitly provided headers take priority over any from tlsOptions\n      extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        'Upgrade': 'websocket',\n        'Connection': 'Upgrade',\n        'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),\n        'Sec-WebSocket-Key': this.base64nonce,\n        'Host': reqHeaders.Host || hostHeaderValue\n    });\n\n    if (this.protocols.length > 0) {\n        reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders['Origin'] = this.origin;\n        }\n        else if (this.config.webSocketVersion === 8) {\n            reqHeaders['Sec-WebSocket-Origin'] = this.origin;\n        }\n    }\n\n    // TODO: Implement extensions\n\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    }\n    else if (this.url.path) {\n        pathAndQuery = '/' + this.url.path;\n    }\n    else {\n        pathAndQuery = '/';\n    }\n\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit('connectFailed', error);\n    }\n\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: 'GET',\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for (var key in tlsOptions) {\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on('upgrade', function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener('error', handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on('error', handleRequestError);\n\n    req.on('response', function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {\n            self.emit('httpResponse', response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        }\n        else {\n            var headerDumpParts = [];\n            for (var headerName in response.headers) {\n                headerDumpParts.push(headerName + ': ' + response.headers[headerName]);\n            }\n            self.failHandshake(\n                'Server responded with a non-101 status: ' +\n                response.statusCode + ' ' + response.statusMessage +\n                '\\nResponse Headers Follow:\\n' +\n                headerDumpParts.join('\\n') + '\\n'\n            );\n        }\n    });\n    req.end();\n};\n\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n\n    if (this.protocols.length > 0) {\n        this.protocol = headers['sec-websocket-protocol'];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake('Server did not respond with a requested protocol.');\n                return;\n            }\n        }\n        else {\n            this.failHandshake('Expected a Sec-WebSocket-Protocol header.');\n            return;\n        }\n    }\n\n    if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {\n        this.failHandshake('Expected a Connection: Upgrade header from the server');\n        return;\n    }\n\n    if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {\n        this.failHandshake('Expected an Upgrade: websocket header from the server');\n        return;\n    }\n\n    var sha1 = crypto.createHash('sha1');\n    sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n    var expectedKey = sha1.digest('base64');\n\n    if (!headers['sec-websocket-accept']) {\n        this.failHandshake('Expected Sec-WebSocket-Accept header from server');\n        return;\n    }\n\n    if (headers['sec-websocket-accept'] !== expectedKey) {\n        this.failHandshake('Sec-WebSocket-Accept header from server didn\\'t match expected value of ' + expectedKey);\n        return;\n    }\n\n    // TODO: Support extensions\n\n    this.succeedHandshake();\n};\n\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit('connectFailed', new Error(errorDescription));\n};\n\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n\n    this.emit('connect', connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\n\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\n\nmodule.exports = WebSocketClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0REFBUztBQUM3QjtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixtQkFBbUIsMERBQThCO0FBQ2pELFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0IsVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QiwwQkFBMEIsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE1BQU0sS0FBSztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldENsaWVudC5qcz8xOWRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGV4dGVuZCA9IHV0aWxzLmV4dGVuZDtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBXZWJTb2NrZXRDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRDb25uZWN0aW9uJyk7XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSB1dGlscy5idWZmZXJBbGxvY1Vuc2FmZTtcblxudmFyIHByb3RvY29sU2VwYXJhdG9ycyA9IFtcbiAgICAnKCcsICcpJywgJzwnLCAnPicsICdAJyxcbiAgICAnLCcsICc7JywgJzonLCAnXFxcXCcsICdcXFwiJyxcbiAgICAnLycsICdbJywgJ10nLCAnPycsICc9JyxcbiAgICAneycsICd9JywgJyAnLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDkpXG5dO1xuXG52YXIgZXhjbHVkZWRUbHNPcHRpb25zID0gWydob3N0bmFtZScsJ3BvcnQnLCdtZXRob2QnLCdwYXRoJywnaGVhZGVycyddO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRDbGllbnQoY29uZmlnKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGV4dGVuc2lvbnNcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAvLyAxTWlCIG1heCBmcmFtZSBzaXplLlxuICAgICAgICBtYXhSZWNlaXZlZEZyYW1lU2l6ZTogMHgxMDAwMDAsXG5cbiAgICAgICAgLy8gOE1pQiBtYXggbWVzc2FnZSBzaXplLCBvbmx5IGFwcGxpY2FibGUgaWZcbiAgICAgICAgLy8gYXNzZW1ibGVGcmFnbWVudHMgaXMgdHJ1ZVxuICAgICAgICBtYXhSZWNlaXZlZE1lc3NhZ2VTaXplOiAweDgwMDAwMCxcblxuICAgICAgICAvLyBPdXRnb2luZyBtZXNzYWdlcyBsYXJnZXIgdGhhbiBmcmFnbWVudGF0aW9uVGhyZXNob2xkIHdpbGwgYmVcbiAgICAgICAgLy8gc3BsaXQgaW50byBtdWx0aXBsZSBmcmFnbWVudHMuXG4gICAgICAgIGZyYWdtZW50T3V0Z29pbmdNZXNzYWdlczogdHJ1ZSxcblxuICAgICAgICAvLyBPdXRnb2luZyBmcmFtZXMgYXJlIGZyYWdtZW50ZWQgaWYgdGhleSBleGNlZWQgdGhpcyB0aHJlc2hvbGQuXG4gICAgICAgIC8vIERlZmF1bHQgaXMgMTZLaUJcbiAgICAgICAgZnJhZ21lbnRhdGlvblRocmVzaG9sZDogMHg0MDAwLFxuXG4gICAgICAgIC8vIFdoaWNoIHZlcnNpb24gb2YgdGhlIHByb3RvY29sIHRvIHVzZSBmb3IgdGhpcyBzZXNzaW9uLiAgVGhpc1xuICAgICAgICAvLyBvcHRpb24gd2lsbCBiZSByZW1vdmVkIG9uY2UgdGhlIHByb3RvY29sIGlzIGZpbmFsaXplZCBieSB0aGUgSUVURlxuICAgICAgICAvLyBJdCBpcyBvbmx5IGF2YWlsYWJsZSB0byBlYXNlIHRoZSB0cmFuc2l0aW9uIHRocm91Z2ggdGhlXG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBkcmFmdCBwcm90b2NvbCB2ZXJzaW9ucy5cbiAgICAgICAgLy8gQXQgcHJlc2VudCwgaXQgb25seSBhZmZlY3RzIHRoZSBuYW1lIG9mIHRoZSBPcmlnaW4gaGVhZGVyLlxuICAgICAgICB3ZWJTb2NrZXRWZXJzaW9uOiAxMyxcblxuICAgICAgICAvLyBJZiB0cnVlLCBmcmFnbWVudGVkIG1lc3NhZ2VzIHdpbGwgYmUgYXV0b21hdGljYWxseSBhc3NlbWJsZWRcbiAgICAgICAgLy8gYW5kIHRoZSBmdWxsIG1lc3NhZ2Ugd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdtZXNzYWdlJyBldmVudC5cbiAgICAgICAgLy8gSWYgZmFsc2UsIGVhY2ggZnJhbWUgd2lsbCBiZSBlbWl0dGVkIHZpYSBhICdmcmFtZScgZXZlbnQgYW5kXG4gICAgICAgIC8vIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGJlIHJlc3BvbnNpYmxlIGZvciBhZ2dyZWdhdGluZyBtdWx0aXBsZVxuICAgICAgICAvLyBmcmFnbWVudGVkIGZyYW1lcy4gIFNpbmdsZS1mcmFtZSBtZXNzYWdlcyB3aWxsIGVtaXQgYSAnbWVzc2FnZSdcbiAgICAgICAgLy8gZXZlbnQgaW4gYWRkaXRpb24gdG8gdGhlICdmcmFtZScgZXZlbnQuXG4gICAgICAgIC8vIE1vc3QgdXNlcnMgd2lsbCB3YW50IHRvIGxlYXZlIHRoaXMgc2V0IHRvICd0cnVlJ1xuICAgICAgICBhc3NlbWJsZUZyYWdtZW50czogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgTmFnbGUgQWxnb3JpdGhtIG1ha2VzIG1vcmUgZWZmaWNpZW50IHVzZSBvZiBuZXR3b3JrIHJlc291cmNlc1xuICAgICAgICAvLyBieSBpbnRyb2R1Y2luZyBhIHNtYWxsIGRlbGF5IGJlZm9yZSBzZW5kaW5nIHNtYWxsIHBhY2tldHMgc28gdGhhdFxuICAgICAgICAvLyBtdWx0aXBsZSBtZXNzYWdlcyBjYW4gYmUgYmF0Y2hlZCB0b2dldGhlciBiZWZvcmUgZ29pbmcgb250byB0aGVcbiAgICAgICAgLy8gd2lyZS4gIFRoaXMgaG93ZXZlciBjb21lcyBhdCB0aGUgY29zdCBvZiBsYXRlbmN5LCBzbyB0aGUgZGVmYXVsdFxuICAgICAgICAvLyBpcyB0byBkaXNhYmxlIGl0LiAgSWYgeW91IGRvbid0IG5lZWQgbG93IGxhdGVuY3kgYW5kIGFyZSBzdHJlYW1pbmdcbiAgICAgICAgLy8gbG90cyBvZiBzbWFsbCBtZXNzYWdlcywgeW91IGNhbiBjaGFuZ2UgdGhpcyB0byAnZmFsc2UnXG4gICAgICAgIGRpc2FibGVOYWdsZUFsZ29yaXRobTogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGFmdGVyIHNlbmRpbmcgYSBjbG9zZSBmcmFtZVxuICAgICAgICAvLyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IHRvIGNvbWUgYmFjayBiZWZvcmUgZ2l2aW5nIHVwIGFuZCBqdXN0XG4gICAgICAgIC8vIGNsb3NpbmcgdGhlIHNvY2tldC5cbiAgICAgICAgY2xvc2VUaW1lb3V0OiA1MDAwLFxuXG4gICAgICAgIC8vIE9wdGlvbnMgdG8gcGFzcyB0byBodHRwcy5jb25uZWN0IGlmIGNvbm5lY3RpbmcgdmlhIFRMU1xuICAgICAgICB0bHNPcHRpb25zOiB7fVxuICAgIH07XG5cbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIHZhciB0bHNPcHRpb25zO1xuICAgICAgICBpZiAoY29uZmlnLnRsc09wdGlvbnMpIHtcbiAgICAgICAgICB0bHNPcHRpb25zID0gY29uZmlnLnRsc09wdGlvbnM7XG4gICAgICAgICAgZGVsZXRlIGNvbmZpZy50bHNPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRsc09wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmQodGhpcy5jb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGV4dGVuZCh0aGlzLmNvbmZpZy50bHNPcHRpb25zLCB0bHNPcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXEgPSBudWxsO1xuICAgIFxuICAgIHN3aXRjaCAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbikge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHdlYlNvY2tldFZlcnNpb24gaXMgbm90IHN1cHBvcnRlZC4gQWxsb3dlZCB2YWx1ZXMgYXJlIDggYW5kIDEzLicpO1xuICAgIH1cbn1cblxudXRpbC5pbmhlcml0cyhXZWJTb2NrZXRDbGllbnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKHJlcXVlc3RVcmwsIHByb3RvY29scywgb3JpZ2luLCBoZWFkZXJzLCBleHRyYVJlcXVlc3RPcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIGlmICh0eXBlb2YocHJvdG9jb2xzKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHByb3RvY29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghKHByb3RvY29scyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5wcm90b2NvbHMgPSBwcm90b2NvbHM7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG5cbiAgICBpZiAodHlwZW9mKHJlcXVlc3RVcmwpID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLnVybCA9IHVybC5wYXJzZShyZXF1ZXN0VXJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMudXJsID0gcmVxdWVzdFVybDsgLy8gaW4gY2FzZSBhbiBhbHJlYWR5IHBhcnNlZCB1cmwgaXMgcGFzc2VkIGluLlxuICAgIH1cbiAgICBpZiAoIXRoaXMudXJsLnByb3RvY29sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGZ1bGwgV2ViU29ja2V0IFVSTCwgaW5jbHVkaW5nIHByb3RvY29sLicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudXJsLmhvc3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgZnVsbCBXZWJTb2NrZXQgVVJMLCBpbmNsdWRpbmcgaG9zdG5hbWUuIFJlbGF0aXZlIFVSTHMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWN1cmUgPSAodGhpcy51cmwucHJvdG9jb2wgPT09ICd3c3M6Jyk7XG5cbiAgICAvLyB2YWxpZGF0ZSBwcm90b2NvbCBjaGFyYWN0ZXJzOlxuICAgIHRoaXMucHJvdG9jb2xzLmZvckVhY2goZnVuY3Rpb24ocHJvdG9jb2wpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcHJvdG9jb2wubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBwcm90b2NvbC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IHByb3RvY29sLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDB4MDAyMSB8fCBjaGFyQ29kZSA+IDB4MDA3RSB8fCBwcm90b2NvbFNlcGFyYXRvcnMuaW5kZXhPZihjaGFyYWN0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdG9jb2wgbGlzdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlciBcIicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSArICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgZGVmYXVsdFBvcnRzID0ge1xuICAgICAgICAnd3M6JzogJzgwJyxcbiAgICAgICAgJ3dzczonOiAnNDQzJ1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMudXJsLnBvcnQpIHtcbiAgICAgICAgdGhpcy51cmwucG9ydCA9IGRlZmF1bHRQb3J0c1t0aGlzLnVybC5wcm90b2NvbF07XG4gICAgfVxuXG4gICAgdmFyIG5vbmNlID0gYnVmZmVyQWxsb2NVbnNhZmUoMTYpO1xuICAgIGZvciAodmFyIGk9MDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgbm9uY2VbaV0gPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkqMHhGRik7XG4gICAgfVxuICAgIHRoaXMuYmFzZTY0bm9uY2UgPSBub25jZS50b1N0cmluZygnYmFzZTY0Jyk7XG5cbiAgICB2YXIgaG9zdEhlYWRlclZhbHVlID0gdGhpcy51cmwuaG9zdG5hbWU7XG4gICAgaWYgKCh0aGlzLnVybC5wcm90b2NvbCA9PT0gJ3dzOicgJiYgdGhpcy51cmwucG9ydCAhPT0gJzgwJykgfHxcbiAgICAgICAgKHRoaXMudXJsLnByb3RvY29sID09PSAnd3NzOicgJiYgdGhpcy51cmwucG9ydCAhPT0gJzQ0MycpKSAge1xuICAgICAgICBob3N0SGVhZGVyVmFsdWUgKz0gKCc6JyArIHRoaXMudXJsLnBvcnQpO1xuICAgIH1cblxuICAgIHZhciByZXFIZWFkZXJzID0ge307XG4gICAgaWYgKHRoaXMuc2VjdXJlICYmIHRoaXMuY29uZmlnLnRsc09wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2hlYWRlcnMnKSkge1xuICAgICAgLy8gQWxsb3cgZm9yIGFkZGl0aW9uYWwgaGVhZGVycyB0byBiZSBwcm92aWRlZCB3aGVuIGNvbm5lY3RpbmcgdmlhIEhUVFBTXG4gICAgICBleHRlbmQocmVxSGVhZGVycywgdGhpcy5jb25maWcudGxzT3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgcHJvdmlkZWQgaGVhZGVycyB0YWtlIHByaW9yaXR5IG92ZXIgYW55IGZyb20gdGxzT3B0aW9uc1xuICAgICAgZXh0ZW5kKHJlcUhlYWRlcnMsIGhlYWRlcnMpO1xuICAgIH1cbiAgICBleHRlbmQocmVxSGVhZGVycywge1xuICAgICAgICAnVXBncmFkZSc6ICd3ZWJzb2NrZXQnLFxuICAgICAgICAnQ29ubmVjdGlvbic6ICdVcGdyYWRlJyxcbiAgICAgICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6IHRoaXMuY29uZmlnLndlYlNvY2tldFZlcnNpb24udG9TdHJpbmcoMTApLFxuICAgICAgICAnU2VjLVdlYlNvY2tldC1LZXknOiB0aGlzLmJhc2U2NG5vbmNlLFxuICAgICAgICAnSG9zdCc6IHJlcUhlYWRlcnMuSG9zdCB8fCBob3N0SGVhZGVyVmFsdWVcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnByb3RvY29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlcUhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnXSA9IHRoaXMucHJvdG9jb2xzLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgICBpZiAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJlcUhlYWRlcnNbJ09yaWdpbiddID0gdGhpcy5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb25maWcud2ViU29ja2V0VmVyc2lvbiA9PT0gOCkge1xuICAgICAgICAgICAgcmVxSGVhZGVyc1snU2VjLVdlYlNvY2tldC1PcmlnaW4nXSA9IHRoaXMub3JpZ2luO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGV4dGVuc2lvbnNcblxuICAgIHZhciBwYXRoQW5kUXVlcnk7XG4gICAgLy8gRW5zdXJlIGl0IGJlZ2lucyB3aXRoICcvJy5cbiAgICBpZiAodGhpcy51cmwucGF0aG5hbWUpIHtcbiAgICAgICAgcGF0aEFuZFF1ZXJ5ID0gdGhpcy51cmwucGF0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy51cmwucGF0aCkge1xuICAgICAgICBwYXRoQW5kUXVlcnkgPSAnLycgKyB0aGlzLnVybC5wYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGF0aEFuZFF1ZXJ5ID0gJy8nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3RFcnJvcihlcnJvcikge1xuICAgICAgICBzZWxmLl9yZXEgPSBudWxsO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nvbm5lY3RGYWlsZWQnLCBlcnJvcik7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBhZ2VudDogZmFsc2VcbiAgICB9O1xuICAgIGlmIChleHRyYVJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChyZXF1ZXN0T3B0aW9ucywgZXh0cmFSZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIFRoZXNlIG9wdGlvbnMgYXJlIGFsd2F5cyBvdmVycmlkZGVuIGJ5IHRoZSBsaWJyYXJ5LiAgVGhlIHVzZXIgaXMgbm90XG4gICAgLy8gYWxsb3dlZCB0byBzcGVjaWZ5IHRoZXNlIGRpcmVjdGx5LlxuICAgIGV4dGVuZChyZXF1ZXN0T3B0aW9ucywge1xuICAgICAgICBob3N0bmFtZTogdGhpcy51cmwuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHRoaXMudXJsLnBvcnQsXG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIHBhdGg6IHBhdGhBbmRRdWVyeSxcbiAgICAgICAgaGVhZGVyczogcmVxSGVhZGVyc1xuICAgIH0pO1xuICAgIGlmICh0aGlzLnNlY3VyZSkge1xuICAgICAgICB2YXIgdGxzT3B0aW9ucyA9IHRoaXMuY29uZmlnLnRsc09wdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0bHNPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGxzT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV4Y2x1ZGVkVGxzT3B0aW9ucy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnNba2V5XSA9IHRsc09wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXEgPSB0aGlzLl9yZXEgPSAodGhpcy5zZWN1cmUgPyBodHRwcyA6IGh0dHApLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgIHJlcS5vbigndXBncmFkZScsIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3RVcGdyYWRlKHJlc3BvbnNlLCBzb2NrZXQsIGhlYWQpIHtcbiAgICAgICAgc2VsZi5fcmVxID0gbnVsbDtcbiAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVJlcXVlc3RFcnJvcik7XG4gICAgICAgIHNlbGYuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICBzZWxmLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHNlbGYuZmlyc3REYXRhQ2h1bmsgPSBoZWFkO1xuICAgICAgICBzZWxmLnZhbGlkYXRlSGFuZHNoYWtlKCk7XG4gICAgfSk7XG4gICAgcmVxLm9uKCdlcnJvcicsIGhhbmRsZVJlcXVlc3RFcnJvcik7XG5cbiAgICByZXEub24oJ3Jlc3BvbnNlJywgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgc2VsZi5fcmVxID0gbnVsbDtcbiAgICAgICAgaWYgKHV0aWxzLmV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQoc2VsZiwgJ2h0dHBSZXNwb25zZScpID4gMCkge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdodHRwUmVzcG9uc2UnLCByZXNwb25zZSwgc2VsZik7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uuc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGhlYWRlckR1bXBQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyRHVtcFBhcnRzLnB1c2goaGVhZGVyTmFtZSArICc6ICcgKyByZXNwb25zZS5oZWFkZXJzW2hlYWRlck5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmFpbEhhbmRzaGFrZShcbiAgICAgICAgICAgICAgICAnU2VydmVyIHJlc3BvbmRlZCB3aXRoIGEgbm9uLTEwMSBzdGF0dXM6ICcgK1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUgKyAnICcgKyByZXNwb25zZS5zdGF0dXNNZXNzYWdlICtcbiAgICAgICAgICAgICAgICAnXFxuUmVzcG9uc2UgSGVhZGVycyBGb2xsb3c6XFxuJyArXG4gICAgICAgICAgICAgICAgaGVhZGVyRHVtcFBhcnRzLmpvaW4oJ1xcbicpICsgJ1xcbidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXEuZW5kKCk7XG59O1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLnZhbGlkYXRlSGFuZHNoYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlLmhlYWRlcnM7XG5cbiAgICBpZiAodGhpcy5wcm90b2NvbHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnByb3RvY29sID0gaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvdG9jb2xzLmluZGV4T2YodGhpcy5wcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdTZXJ2ZXIgZGlkIG5vdCByZXNwb25kIHdpdGggYSByZXF1ZXN0ZWQgcHJvdG9jb2wuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mYWlsSGFuZHNoYWtlKCdFeHBlY3RlZCBhIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgaGVhZGVyLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoaGVhZGVyc1snY29ubmVjdGlvbiddICYmIGhlYWRlcnNbJ2Nvbm5lY3Rpb24nXS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSAndXBncmFkZScpKSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnRXhwZWN0ZWQgYSBDb25uZWN0aW9uOiBVcGdyYWRlIGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGhlYWRlcnNbJ3VwZ3JhZGUnXSAmJiBoZWFkZXJzWyd1cGdyYWRlJ10udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gJ3dlYnNvY2tldCcpKSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnRXhwZWN0ZWQgYW4gVXBncmFkZTogd2Vic29ja2V0IGhlYWRlciBmcm9tIHRoZSBzZXJ2ZXInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaGExID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTEnKTtcbiAgICBzaGExLnVwZGF0ZSh0aGlzLmJhc2U2NG5vbmNlICsgJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScpO1xuICAgIHZhciBleHBlY3RlZEtleSA9IHNoYTEuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGlmICghaGVhZGVyc1snc2VjLXdlYnNvY2tldC1hY2NlcHQnXSkge1xuICAgICAgICB0aGlzLmZhaWxIYW5kc2hha2UoJ0V4cGVjdGVkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlciBmcm9tIHNlcnZlcicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGV4cGVjdGVkS2V5KSB7XG4gICAgICAgIHRoaXMuZmFpbEhhbmRzaGFrZSgnU2VjLVdlYlNvY2tldC1BY2NlcHQgaGVhZGVyIGZyb20gc2VydmVyIGRpZG5cXCd0IG1hdGNoIGV4cGVjdGVkIHZhbHVlIG9mICcgKyBleHBlY3RlZEtleSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IGV4dGVuc2lvbnNcblxuICAgIHRoaXMuc3VjY2VlZEhhbmRzaGFrZSgpO1xufTtcblxuV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZS5mYWlsSGFuZHNoYWtlID0gZnVuY3Rpb24oZXJyb3JEZXNjcmlwdGlvbikge1xuICAgIGlmICh0aGlzLnNvY2tldCAmJiB0aGlzLnNvY2tldC53cml0YWJsZSkge1xuICAgICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0RmFpbGVkJywgbmV3IEVycm9yKGVycm9yRGVzY3JpcHRpb24pKTtcbn07XG5cbldlYlNvY2tldENsaWVudC5wcm90b3R5cGUuc3VjY2VlZEhhbmRzaGFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFdlYlNvY2tldENvbm5lY3Rpb24odGhpcy5zb2NrZXQsIFtdLCB0aGlzLnByb3RvY29sLCB0cnVlLCB0aGlzLmNvbmZpZyk7XG5cbiAgICBjb25uZWN0aW9uLndlYlNvY2tldFZlcnNpb24gPSB0aGlzLmNvbmZpZy53ZWJTb2NrZXRWZXJzaW9uO1xuICAgIGNvbm5lY3Rpb24uX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBjb25uZWN0aW9uKTtcbiAgICBpZiAodGhpcy5maXJzdERhdGFDaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uaGFuZGxlU29ja2V0RGF0YSh0aGlzLmZpcnN0RGF0YUNodW5rKTtcbiAgICB9XG4gICAgdGhpcy5maXJzdERhdGFDaHVuayA9IG51bGw7XG59O1xuXG5XZWJTb2NrZXRDbGllbnQucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3JlcSkge1xuICAgICAgICB0aGlzLl9yZXEuYWJvcnQoKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldENsaWVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketConnection.js":
/*!***********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketConnection.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketFrame = __webpack_require__(/*! ./WebSocketFrame */ \"(ssr)/./node_modules/websocket/lib/WebSocketFrame.js\");\nvar BufferList = __webpack_require__(/*! ../vendor/FastBufferList */ \"(ssr)/./node_modules/websocket/vendor/FastBufferList.js\");\nvar isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"(ssr)/./node_modules/utf-8-validate/index.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString;\n\n// Connected, fully-open, ready to send and receive frames\nconst STATE_OPEN = 'open';\n// Received a close frame from the remote peer\nconst STATE_PEER_REQUESTED_CLOSE = 'peer_requested_close';\n// Sent close frame to remote peer.  No further data can be sent.\nconst STATE_ENDING = 'ending';\n// Connection is fully closed.  No further data can be sent or received.\nconst STATE_CLOSED = 'closed';\n\nvar setImmediateImpl = ('setImmediate' in global) ?\n                            global.setImmediate.bind(global) :\n                            process.nextTick.bind(process);\n\nvar idCounter = 0;\n\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n    this._debug = utils.BufferingLogger('websocket:connection', ++idCounter);\n    this._debug('constructor');\n    \n    if (this._debug.enabled) {\n        instrumentSocketForDebugging(this, socket);\n    }\n    \n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._pingListenerCount = 0;\n    this.on('newListener', function(ev) {\n        if (ev === 'ping'){\n            this._pingListenerCount++;\n        }\n      }).on('removeListener', function(ev) {\n        if (ev === 'ping') {\n            this._pingListenerCount--;\n        }\n    });\n\n    this.config = config;\n    this.socket = socket;\n    this.protocol = protocol;\n    this.extensions = extensions;\n    this.remoteAddress = socket.remoteAddress;\n    this.closeReasonCode = -1;\n    this.closeDescription = null;\n    this.closeEventEmitted = false;\n\n    // We have to mask outgoing packets if we're acting as a WebSocket client.\n    this.maskOutgoingPackets = maskOutgoingPackets;\n\n    // We re-use the same buffers for the mask and frame header for all frames\n    // received on each connection to avoid a small memory allocation for each\n    // frame.\n    this.maskBytes = bufferAllocUnsafe(4);\n    this.frameHeader = bufferAllocUnsafe(10);\n\n    // the BufferList will handle the data streaming in\n    this.bufferList = new BufferList();\n\n    // Prepare for receiving first frame\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    this.fragmentationSize = 0; // data received so far...\n    this.frameQueue = [];\n    \n    // Various bits of connection state\n    this.connected = true;\n    this.state = STATE_OPEN;\n    this.waitingForCloseResponse = false;\n    // Received TCP FIN, socket's readable stream is finished.\n    this.receivedEnd = false;\n\n    this.closeTimeout = this.config.closeTimeout;\n    this.assembleFragments = this.config.assembleFragments;\n    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n\n    this.outputBufferFull = false;\n    this.inputPaused = false;\n    this.receivedDataHandler = this.processReceivedData.bind(this);\n    this._closeTimerHandler = this.handleCloseTimer.bind(this);\n\n    // Disable nagle algorithm?\n    this.socket.setNoDelay(this.config.disableNagleAlgorithm);\n\n    // Make sure there is no socket inactivity timeout\n    this.socket.setTimeout(0);\n\n    if (this.config.keepalive && !this.config.useNativeKeepalive) {\n        if (typeof(this.config.keepaliveInterval) !== 'number') {\n            throw new Error('keepaliveInterval must be specified and numeric ' +\n                            'if keepalive is true.');\n        }\n        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n        this.setKeepaliveTimer();\n\n        if (this.config.dropConnectionOnKeepaliveTimeout) {\n            if (typeof(this.config.keepaliveGracePeriod) !== 'number') {\n                throw new Error('keepaliveGracePeriod  must be specified and ' +\n                                'numeric if dropConnectionOnKeepaliveTimeout ' +\n                                'is true.');\n            }\n            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n        }\n    }\n    else if (this.config.keepalive && this.config.useNativeKeepalive) {\n        if (!('setKeepAlive' in this.socket)) {\n            throw new Error('Unable to use native keepalive: unsupported by ' +\n                            'this version of Node.');\n        }\n        this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n    }\n    \n    // The HTTP Client seems to subscribe to socket error events\n    // and re-dispatch them in such a way that doesn't make sense\n    // for users of our client, so we want to make sure nobody\n    // else is listening for error events on the socket besides us.\n    this.socket.removeAllListeners('error');\n}\n\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\n\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n    1000: 'Normal connection closure',\n    1001: 'Remote peer is going away',\n    1002: 'Protocol error',\n    1003: 'Unprocessable input',\n    1004: 'Reserved',\n    1005: 'Reason not provided',\n    1006: 'Abnormal closure, no further detail available',\n    1007: 'Invalid data received',\n    1008: 'Policy violation',\n    1009: 'Message too big',\n    1010: 'Extension requested by client is required',\n    1011: 'Internal Server Error',\n    1015: 'TLS Handshake Failed'\n};\n\nfunction validateCloseReason(code) {\n    if (code < 1000) {\n        // Status codes in the range 0-999 are not used\n        return false;\n    }\n    if (code >= 1000 && code <= 2999) {\n        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n        // a few codes are defined, all others are currently illegal.\n        return [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015].indexOf(code) !== -1;\n    }\n    if (code >= 3000 && code <= 3999) {\n        // Reserved for use by libraries, frameworks, and applications.\n        // Should be registered with IANA.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 4000 && code <= 4999) {\n        // Reserved for private use.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 5000) {\n        return false;\n    }\n}\n\nutil.inherits(WebSocketConnection, EventEmitter);\n\nWebSocketConnection.prototype._addSocketEventListeners = function() {\n    this.socket.on('error', this.handleSocketError.bind(this));\n    this.socket.on('end', this.handleSocketEnd.bind(this));\n    this.socket.on('close', this.handleSocketClose.bind(this));\n    this.socket.on('drain', this.handleSocketDrain.bind(this));\n    this.socket.on('pause', this.handleSocketPause.bind(this));\n    this.socket.on('resume', this.handleSocketResume.bind(this));\n    this.socket.on('data', this.handleSocketData.bind(this));\n};\n\n// set or reset the keepalive timer when data is received.\nWebSocketConnection.prototype.setKeepaliveTimer = function() {\n    this._debug('setKeepaliveTimer');\n    if (!this.config.keepalive  || this.config.useNativeKeepalive) { return; }\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\n\nWebSocketConnection.prototype.clearKeepaliveTimer = function() {\n    if (this._keepaliveTimeoutID) {\n        clearTimeout(this._keepaliveTimeoutID);\n    }\n};\n\n// No data has been received within config.keepaliveTimeout ms.\nWebSocketConnection.prototype.handleKeepaliveTimer = function() {\n    this._debug('handleKeepaliveTimer');\n    this._keepaliveTimeoutID = null;\n    this.ping();\n\n    // If we are configured to drop connections if the client doesn't respond\n    // then set the grace period timer.\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n        this.setGracePeriodTimer();\n    }\n    else {\n        // Otherwise reset the keepalive timer to send the next ping.\n        this.setKeepaliveTimer();\n    }\n};\n\nWebSocketConnection.prototype.setGracePeriodTimer = function() {\n    this._debug('setGracePeriodTimer');\n    this.clearGracePeriodTimer();\n    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\n\nWebSocketConnection.prototype.clearGracePeriodTimer = function() {\n    if (this._gracePeriodTimeoutID) {\n        clearTimeout(this._gracePeriodTimeoutID);\n    }\n};\n\nWebSocketConnection.prototype.handleGracePeriodTimer = function() {\n    this._debug('handleGracePeriodTimer');\n    // If this is called, the client has not responded and is assumed dead.\n    this._gracePeriodTimeoutID = null;\n    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, 'Peer not responding.', true);\n};\n\nWebSocketConnection.prototype.handleSocketData = function(data) {\n    this._debug('handleSocketData');\n    // Reset the keepalive timer when receiving data of any kind.\n    this.setKeepaliveTimer();\n\n    // Add received data to our bufferList, which efficiently holds received\n    // data chunks in a linked list of Buffer objects.\n    this.bufferList.write(data);\n\n    this.processReceivedData();\n};\n\nWebSocketConnection.prototype.processReceivedData = function() {\n    this._debug('processReceivedData');\n    // If we're not connected, we should ignore any data remaining on the buffer.\n    if (!this.connected) { return; }\n\n    // Receiving/parsing is expected to be halted when paused.\n    if (this.inputPaused) { return; }\n\n    var frame = this.currentFrame;\n\n    // WebSocketFrame.prototype.addData returns true if all data necessary to\n    // parse the frame was available.  It returns false if we are waiting for\n    // more data to come in on the wire.\n    if (!frame.addData(this.bufferList)) { this._debug('-- insufficient data for frame'); return; }\n\n    var self = this;\n\n    // Handle possible parsing errors\n    if (frame.protocolError) {\n        // Something bad happened.. get rid of this client.\n        this._debug('-- protocol error');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n        });\n        return;\n    }\n    else if (frame.frameTooLarge) {\n        this._debug('-- frame too large');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n        });\n        return;\n    }\n\n    // For now since we don't support extensions, all RSV bits are illegal\n    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n        this._debug('-- illegal rsv flag');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n              'Unsupported usage of rsv bits without negotiated extension.');\n        });\n        return;\n    }\n\n    if (!this.assembleFragments) {\n        this._debug('-- emitting frame');\n        process.nextTick(function() { self.emit('frame', frame); });\n    }\n\n    process.nextTick(function() { self.processFrame(frame); });\n    \n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n\n    // If there's data remaining, schedule additional processing, but yield\n    // for now so that other connections have a chance to have their data\n    // processed.  We use setImmediate here instead of process.nextTick to\n    // explicitly indicate that we wish for other I/O to be handled first.\n    if (this.bufferList.length > 0) {\n        setImmediateImpl(this.receivedDataHandler);\n    }\n};\n\nWebSocketConnection.prototype.handleSocketError = function(error) {\n    this._debug('handleSocketError: %j', error);\n    if (this.state === STATE_CLOSED) {\n\t\t// See https://github.com/theturtle32/WebSocket-Node/issues/288\n        this._debug('  --- Socket \\'error\\' after \\'close\\'');\n        return;\n    }\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = 'Socket Error: ' + error.syscall + ' ' + error.code;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.fragmentationSize = 0;\n    if (utils.eventEmitterListenerCount(this, 'error') > 0) {\n        this.emit('error', error);\n    }\n    this.socket.destroy();\n    this._debug.printOutput();\n};\n\nWebSocketConnection.prototype.handleSocketEnd = function() {\n    this._debug('handleSocketEnd: received socket end.  state = %s', this.state);\n    this.receivedEnd = true;\n    if (this.state === STATE_CLOSED) {\n        // When using the TLS module, sometimes the socket will emit 'end'\n        // after it emits 'close'.  I don't think that's correct behavior,\n        // but we should deal with it gracefully by ignoring it.\n        this._debug('  --- Socket \\'end\\' after \\'close\\'');\n        return;\n    }\n    if (this.state !== STATE_PEER_REQUESTED_CLOSE &&\n        this.state !== STATE_ENDING) {\n      this._debug('  --- UNEXPECTED socket end.');\n      this.socket.end();\n    }\n};\n\nWebSocketConnection.prototype.handleSocketClose = function(hadError) {\n    this._debug('handleSocketClose: received socket close');\n    this.socketHadError = hadError;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    // If closeReasonCode is still set to -1 at this point then we must\n    // not have received a close frame!!\n    if (this.closeReasonCode === -1) {\n        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n        this.closeDescription = 'Connection dropped by remote peer.';\n    }\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug('-- Emitting WebSocketConnection close event');\n        this.emit('close', this.closeReasonCode, this.closeDescription);\n    }\n};\n\nWebSocketConnection.prototype.handleSocketDrain = function() {\n    this._debug('handleSocketDrain: socket drain event');\n    this.outputBufferFull = false;\n    this.emit('drain');\n};\n\nWebSocketConnection.prototype.handleSocketPause = function() {\n    this._debug('handleSocketPause: socket pause event');\n    this.inputPaused = true;\n    this.emit('pause');\n};\n\nWebSocketConnection.prototype.handleSocketResume = function() {\n    this._debug('handleSocketResume: socket resume event');\n    this.inputPaused = false;\n    this.emit('resume');\n    this.processReceivedData();\n};\n\nWebSocketConnection.prototype.pause = function() {\n    this._debug('pause: pause requested');\n    this.socket.pause();\n};\n\nWebSocketConnection.prototype.resume = function() {\n    this._debug('resume: resume requested');\n    this.socket.resume();\n};\n\nWebSocketConnection.prototype.close = function(reasonCode, description) {\n    if (this.connected) {\n        this._debug('close: Initating clean WebSocket close sequence.');\n        if ('number' !== typeof reasonCode) {\n            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n        }\n        if (!validateCloseReason(reasonCode)) {\n            throw new Error('Close code ' + reasonCode + ' is not valid.');\n        }\n        if ('string' !== typeof description) {\n            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n        }\n        this.closeReasonCode = reasonCode;\n        this.closeDescription = description;\n        this.setCloseTimer();\n        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n        this.state = STATE_ENDING;\n        this.connected = false;\n    }\n};\n\nWebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {\n    this._debug('drop');\n    if (typeof(reasonCode) !== 'number') {\n        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n    }\n\n    if (typeof(description) !== 'string') {\n        // If no description is provided, try to look one up based on the\n        // specified reasonCode.\n        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n\n    this._debug('Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s',\n        skipCloseFrame, reasonCode, description\n    );\n\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.frameQueue = [];\n    this.fragmentationSize = 0;\n    if (!skipCloseFrame) {\n        this.sendCloseFrame(reasonCode, description);\n    }\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug('Emitting WebSocketConnection close event');\n        this.emit('close', this.closeReasonCode, this.closeDescription);\n    }\n    \n    this._debug('Drop: destroying socket');\n    this.socket.destroy();\n};\n\nWebSocketConnection.prototype.setCloseTimer = function() {\n    this._debug('setCloseTimer');\n    this.clearCloseTimer();\n    this._debug('Setting close timer');\n    this.waitingForCloseResponse = true;\n    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\n\nWebSocketConnection.prototype.clearCloseTimer = function() {\n    this._debug('clearCloseTimer');\n    if (this.closeTimer) {\n        this._debug('Clearing close timer');\n        clearTimeout(this.closeTimer);\n        this.waitingForCloseResponse = false;\n        this.closeTimer = null;\n    }\n};\n\nWebSocketConnection.prototype.handleCloseTimer = function() {\n    this._debug('handleCloseTimer');\n    this.closeTimer = null;\n    if (this.waitingForCloseResponse) {\n        this._debug('Close response not received from client.  Forcing socket end.');\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n    }\n};\n\nWebSocketConnection.prototype.processFrame = function(frame) {\n    this._debug('processFrame');\n    this._debug(' -- frame: %s', frame);\n    \n    // Any non-control opcode besides 0x00 (continuation) received in the\n    // middle of a fragmented message is illegal.\n    if (this.frameQueue.length !== 0 && (frame.opcode > 0x00 && frame.opcode < 0x08)) {\n        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n          'Illegal frame opcode 0x' + frame.opcode.toString(16) + ' ' +\n          'received in middle of fragmented message.');\n        return;\n    }\n\n    switch(frame.opcode) {\n        case 0x02: // WebSocketFrame.BINARY_FRAME\n            this._debug('-- Binary Frame');\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    // Complete single-frame message received\n                    this._debug('---- Emitting \\'message\\' event');\n                    this.emit('message', {\n                        type: 'binary',\n                        binaryData: frame.binaryPayload\n                    });\n                }\n                else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x01: // WebSocketFrame.TEXT_FRAME\n            this._debug('-- Text Frame');\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    if (!isValidUTF8(frame.binaryPayload)) {\n                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                          'Invalid UTF-8 Data Received');\n                        return;\n                    }\n                    // Complete single-frame message received\n                    this._debug('---- Emitting \\'message\\' event');\n                    this.emit('message', {\n                        type: 'utf8',\n                        utf8Data: frame.binaryPayload.toString('utf8')\n                    });\n                }\n                else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x00: // WebSocketFrame.CONTINUATION\n            this._debug('-- Continuation Frame');\n            if (this.assembleFragments) {\n                if (this.frameQueue.length === 0) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n                      'Unexpected Continuation Frame');\n                    return;\n                }\n\n                this.fragmentationSize += frame.length;\n\n                if (this.fragmentationSize > this.maxReceivedMessageSize) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,\n                      'Maximum message size exceeded.');\n                    return;\n                }\n\n                this.frameQueue.push(frame);\n\n                if (frame.fin) {\n                    // end of fragmented message, so we process the whole\n                    // message now.  We also have to decode the utf-8 data\n                    // for text frames after combining all the fragments.\n                    var bytesCopied = 0;\n                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n                    var opcode = this.frameQueue[0].opcode;\n                    this.frameQueue.forEach(function (currentFrame) {\n                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n                        bytesCopied += currentFrame.binaryPayload.length;\n                    });\n                    this.frameQueue = [];\n                    this.fragmentationSize = 0;\n\n                    switch (opcode) {\n                        case 0x02: // WebSocketOpcode.BINARY_FRAME\n                            this.emit('message', {\n                                type: 'binary',\n                                binaryData: binaryPayload\n                            });\n                            break;\n                        case 0x01: // WebSocketOpcode.TEXT_FRAME\n                            if (!isValidUTF8(binaryPayload)) {\n                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                                  'Invalid UTF-8 Data Received');\n                                return;\n                            }\n                            this.emit('message', {\n                                type: 'utf8',\n                                utf8Data: binaryPayload.toString('utf8')\n                            });\n                            break;\n                        default:\n                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n                              'Unexpected first opcode in fragmentation sequence: 0x' + opcode.toString(16));\n                            return;\n                    }\n                }\n            }\n            break;\n        case 0x09: // WebSocketFrame.PING\n            this._debug('-- Ping Frame');\n\n            if (this._pingListenerCount > 0) {\n                // logic to emit the ping frame: this is only done when a listener is known to exist\n                // Expose a function allowing the user to override the default ping() behavior\n                var cancelled = false;\n                var cancel = function() { \n                  cancelled = true; \n                };\n                this.emit('ping', cancel, frame.binaryPayload);\n\n                // Only send a pong if the client did not indicate that he would like to cancel\n                if (!cancelled) {\n                    this.pong(frame.binaryPayload);\n                }\n            }\n            else {\n                this.pong(frame.binaryPayload);\n            }\n\n            break;\n        case 0x0A: // WebSocketFrame.PONG\n            this._debug('-- Pong Frame');\n            this.emit('pong', frame.binaryPayload);\n            break;\n        case 0x08: // WebSocketFrame.CONNECTION_CLOSE\n            this._debug('-- Close Frame');\n            if (this.waitingForCloseResponse) {\n                // Got response to our request to close the connection.\n                // Close is complete, so we just hang up.\n                this._debug('---- Got close response from peer.  Completing closing handshake.');\n                this.clearCloseTimer();\n                this.waitingForCloseResponse = false;\n                this.state = STATE_CLOSED;\n                this.socket.end();\n                return;\n            }\n            \n            this._debug('---- Closing handshake initiated by peer.');\n            // Got request from other party to close connection.\n            // Send back acknowledgement and then hang up.\n            this.state = STATE_PEER_REQUESTED_CLOSE;\n            var respondCloseReasonCode;\n\n            // Make sure the close reason provided is legal according to\n            // the protocol spec.  Providing no close status is legal.\n            // WebSocketFrame sets closeStatus to -1 by default, so if it\n            // is still -1, then no status was provided.\n            if (frame.invalidCloseFrameLength) {\n                this.closeReasonCode = 1005; // 1005 = No reason provided.\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n            }\n            else {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            \n            // If there is a textual description in the close frame, extract it.\n            if (frame.binaryPayload.length > 1) {\n                if (!isValidUTF8(frame.binaryPayload)) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                      'Invalid UTF-8 Data Received');\n                    return;\n                }\n                this.closeDescription = frame.binaryPayload.toString('utf8');\n            }\n            else {\n                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n            }\n            this._debug(\n                '------ Remote peer %s - code: %d - %s - close frame payload length: %d',\n                this.remoteAddress, this.closeReasonCode,\n                this.closeDescription, frame.length\n            );\n            this._debug('------ responding to remote peer\\'s close request.');\n            this.sendCloseFrame(respondCloseReasonCode, null);\n            this.connected = false;\n            break;\n        default:\n            this._debug('-- Unrecognized Opcode %d', frame.opcode);\n            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n              'Unrecognized Opcode: 0x' + frame.opcode.toString(16));\n            break;\n    }\n};\n\nWebSocketConnection.prototype.send = function(data, cb) {\n    this._debug('send');\n    if (Buffer.isBuffer(data)) {\n        this.sendBytes(data, cb);\n    }\n    else if (typeof(data['toString']) === 'function') {\n        this.sendUTF(data, cb);\n    }\n    else {\n        throw new Error('Data provided must either be a Node Buffer or implement toString()');\n    }\n};\n\nWebSocketConnection.prototype.sendUTF = function(data, cb) {\n    data = bufferFromString(data.toString(), 'utf8');\n    this._debug('sendUTF: %d bytes', data.length);\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.sendBytes = function(data, cb) {\n    this._debug('sendBytes');\n    if (!Buffer.isBuffer(data)) {\n        throw new Error('You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()');\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.ping = function(data) {\n    this._debug('ping');\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x09; // WebSocketOpcode.PING\n    frame.fin = true;\n    if (data) {\n        if (!Buffer.isBuffer(data)) {\n            data = bufferFromString(data.toString(), 'utf8');\n        }\n        if (data.length > 125) {\n            this._debug('WebSocket: Data for ping is longer than 125 bytes.  Truncating.');\n            data = data.slice(0,124);\n        }\n        frame.binaryPayload = data;\n    }\n    this.sendFrame(frame);\n};\n\n// Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\nWebSocketConnection.prototype.pong = function(binaryPayload) {\n    this._debug('pong');\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x0A; // WebSocketOpcode.PONG\n    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n        this._debug('WebSocket: Data for pong is longer than 125 bytes.  Truncating.');\n        binaryPayload = binaryPayload.slice(0,124);\n    }\n    frame.binaryPayload = binaryPayload;\n    frame.fin = true;\n    this.sendFrame(frame);\n};\n\nWebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {\n    this._debug('fragmentAndSend');\n    if (frame.opcode > 0x07) {\n        throw new Error('You cannot fragment control frames.');\n    }\n\n    var threshold = this.config.fragmentationThreshold;\n    var length = frame.binaryPayload.length;\n\n    // Send immediately if fragmentation is disabled or the message is not\n    // larger than the fragmentation threshold.\n    if (!this.config.fragmentOutgoingMessages || (frame.binaryPayload && length <= threshold)) {\n        frame.fin = true;\n        this.sendFrame(frame, cb);\n        return;\n    }\n    \n    var numFragments = Math.ceil(length / threshold);\n    var sentFragments = 0;\n    var sentCallback = function fragmentSentCallback(err) {\n        if (err) {\n            if (typeof cb === 'function') {\n                // pass only the first error\n                cb(err);\n                cb = null;\n            }\n            return;\n        }\n        ++sentFragments;\n        if ((sentFragments === numFragments) && (typeof cb === 'function')) {\n            cb();\n        }\n    };\n    for (var i=1; i <= numFragments; i++) {\n        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n        \n        // continuation opcode except for first frame.\n        currentFrame.opcode = (i === 1) ? frame.opcode : 0x00;\n        \n        // fin set on last frame only\n        currentFrame.fin = (i === numFragments);\n        \n        // length is likely to be shorter on the last fragment\n        var currentLength = (i === numFragments) ? length - (threshold * (i-1)) : threshold;\n        var sliceStart = threshold * (i-1);\n        \n        // Slice the right portion of the original payload\n        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n        \n        this.sendFrame(currentFrame, sentCallback);\n    }\n};\n\nWebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {\n    if (typeof(reasonCode) !== 'number') {\n        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n    \n    this._debug('sendCloseFrame state: %s, reasonCode: %d, description: %s', this.state, reasonCode, description);\n    \n    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) { return; }\n    \n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.fin = true;\n    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n    frame.closeStatus = reasonCode;\n    if (typeof(description) === 'string') {\n        frame.binaryPayload = bufferFromString(description, 'utf8');\n    }\n    \n    this.sendFrame(frame, cb);\n    this.socket.end();\n};\n\nWebSocketConnection.prototype.sendFrame = function(frame, cb) {\n    this._debug('sendFrame');\n    frame.mask = this.maskOutgoingPackets;\n    var flushed = this.socket.write(frame.toBuffer(), cb);\n    this.outputBufferFull = !flushed;\n    return flushed;\n};\n\nmodule.exports = WebSocketConnection;\n\n\n\nfunction instrumentSocketForDebugging(connection, socket) {\n    /* jshint loopfunc: true */\n    if (!connection._debug.enabled) { return; }\n    \n    var originalSocketEmit = socket.emit;\n    socket.emit = function(event) {\n        connection._debug('||| Socket Event  \\'%s\\'', event);\n        originalSocketEmit.apply(this, arguments);\n    };\n    \n    for (var key in socket) {\n        if ('function' !== typeof(socket[key])) { continue; }\n        if (['emit'].indexOf(key) !== -1) { continue; }\n        (function(key) {\n            var original = socket[key];\n            if (key === 'on') {\n                socket[key] = function proxyMethod__EventEmitter__On() {\n                    connection._debug('||| Socket method called:  %s (%s)', key, arguments[0]);\n                    return original.apply(this, arguments);\n                };\n                return;\n            }\n            socket[key] = function proxyMethod() {\n                connection._debug('||| Socket method called:  %s', key);\n                return original.apply(this, arguments);\n            };\n        })(key);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRDb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLDREQUFTO0FBQzdCLG1CQUFtQiwwREFBOEI7QUFDakQscUJBQXFCLG1CQUFPLENBQUMsOEVBQWtCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLHlGQUEwQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyxvRUFBZ0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELHNEQUFzRDtBQUN0RCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtDQUErQzs7QUFFMUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsNEJBQTRCO0FBQ2xFOztBQUVBLGtDQUFrQywyQkFBMkI7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnByb2RpZ2llcy1jeXByZXNzLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvV2ViU29ja2V0Q29ubmVjdGlvbi5qcz9mNmFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFdlYlNvY2tldEZyYW1lID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRGcmFtZScpO1xudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuLi92ZW5kb3IvRmFzdEJ1ZmZlckxpc3QnKTtcbnZhciBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSB1dGlscy5idWZmZXJBbGxvY1Vuc2FmZTtcbnZhciBidWZmZXJGcm9tU3RyaW5nID0gdXRpbHMuYnVmZmVyRnJvbVN0cmluZztcblxuLy8gQ29ubmVjdGVkLCBmdWxseS1vcGVuLCByZWFkeSB0byBzZW5kIGFuZCByZWNlaXZlIGZyYW1lc1xuY29uc3QgU1RBVEVfT1BFTiA9ICdvcGVuJztcbi8vIFJlY2VpdmVkIGEgY2xvc2UgZnJhbWUgZnJvbSB0aGUgcmVtb3RlIHBlZXJcbmNvbnN0IFNUQVRFX1BFRVJfUkVRVUVTVEVEX0NMT1NFID0gJ3BlZXJfcmVxdWVzdGVkX2Nsb3NlJztcbi8vIFNlbnQgY2xvc2UgZnJhbWUgdG8gcmVtb3RlIHBlZXIuICBObyBmdXJ0aGVyIGRhdGEgY2FuIGJlIHNlbnQuXG5jb25zdCBTVEFURV9FTkRJTkcgPSAnZW5kaW5nJztcbi8vIENvbm5lY3Rpb24gaXMgZnVsbHkgY2xvc2VkLiAgTm8gZnVydGhlciBkYXRhIGNhbiBiZSBzZW50IG9yIHJlY2VpdmVkLlxuY29uc3QgU1RBVEVfQ0xPU0VEID0gJ2Nsb3NlZCc7XG5cbnZhciBzZXRJbW1lZGlhdGVJbXBsID0gKCdzZXRJbW1lZGlhdGUnIGluIGdsb2JhbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbC5zZXRJbW1lZGlhdGUuYmluZChnbG9iYWwpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrLmJpbmQocHJvY2Vzcyk7XG5cbnZhciBpZENvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRDb25uZWN0aW9uKHNvY2tldCwgZXh0ZW5zaW9ucywgcHJvdG9jb2wsIG1hc2tPdXRnb2luZ1BhY2tldHMsIGNvbmZpZykge1xuICAgIHRoaXMuX2RlYnVnID0gdXRpbHMuQnVmZmVyaW5nTG9nZ2VyKCd3ZWJzb2NrZXQ6Y29ubmVjdGlvbicsICsraWRDb3VudGVyKTtcbiAgICB0aGlzLl9kZWJ1ZygnY29uc3RydWN0b3InKTtcbiAgICBcbiAgICBpZiAodGhpcy5fZGVidWcuZW5hYmxlZCkge1xuICAgICAgICBpbnN0cnVtZW50U29ja2V0Rm9yRGVidWdnaW5nKHRoaXMsIHNvY2tldCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX3BpbmdMaXN0ZW5lckNvdW50ID0gMDtcbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChldiA9PT0gJ3BpbmcnKXtcbiAgICAgICAgICAgIHRoaXMuX3BpbmdMaXN0ZW5lckNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pLm9uKCdyZW1vdmVMaXN0ZW5lcicsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChldiA9PT0gJ3BpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9waW5nTGlzdGVuZXJDb3VudC0tO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IC0xO1xuICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCA9IGZhbHNlO1xuXG4gICAgLy8gV2UgaGF2ZSB0byBtYXNrIG91dGdvaW5nIHBhY2tldHMgaWYgd2UncmUgYWN0aW5nIGFzIGEgV2ViU29ja2V0IGNsaWVudC5cbiAgICB0aGlzLm1hc2tPdXRnb2luZ1BhY2tldHMgPSBtYXNrT3V0Z29pbmdQYWNrZXRzO1xuXG4gICAgLy8gV2UgcmUtdXNlIHRoZSBzYW1lIGJ1ZmZlcnMgZm9yIHRoZSBtYXNrIGFuZCBmcmFtZSBoZWFkZXIgZm9yIGFsbCBmcmFtZXNcbiAgICAvLyByZWNlaXZlZCBvbiBlYWNoIGNvbm5lY3Rpb24gdG8gYXZvaWQgYSBzbWFsbCBtZW1vcnkgYWxsb2NhdGlvbiBmb3IgZWFjaFxuICAgIC8vIGZyYW1lLlxuICAgIHRoaXMubWFza0J5dGVzID0gYnVmZmVyQWxsb2NVbnNhZmUoNCk7XG4gICAgdGhpcy5mcmFtZUhlYWRlciA9IGJ1ZmZlckFsbG9jVW5zYWZlKDEwKTtcblxuICAgIC8vIHRoZSBCdWZmZXJMaXN0IHdpbGwgaGFuZGxlIHRoZSBkYXRhIHN0cmVhbWluZyBpblxuICAgIHRoaXMuYnVmZmVyTGlzdCA9IG5ldyBCdWZmZXJMaXN0KCk7XG5cbiAgICAvLyBQcmVwYXJlIGZvciByZWNlaXZpbmcgZmlyc3QgZnJhbWVcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSAwOyAvLyBkYXRhIHJlY2VpdmVkIHNvIGZhci4uLlxuICAgIHRoaXMuZnJhbWVRdWV1ZSA9IFtdO1xuICAgIFxuICAgIC8vIFZhcmlvdXMgYml0cyBvZiBjb25uZWN0aW9uIHN0YXRlXG4gICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9PUEVOO1xuICAgIHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAvLyBSZWNlaXZlZCBUQ1AgRklOLCBzb2NrZXQncyByZWFkYWJsZSBzdHJlYW0gaXMgZmluaXNoZWQuXG4gICAgdGhpcy5yZWNlaXZlZEVuZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5jbG9zZVRpbWVvdXQgPSB0aGlzLmNvbmZpZy5jbG9zZVRpbWVvdXQ7XG4gICAgdGhpcy5hc3NlbWJsZUZyYWdtZW50cyA9IHRoaXMuY29uZmlnLmFzc2VtYmxlRnJhZ21lbnRzO1xuICAgIHRoaXMubWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSA9IHRoaXMuY29uZmlnLm1heFJlY2VpdmVkTWVzc2FnZVNpemU7XG5cbiAgICB0aGlzLm91dHB1dEJ1ZmZlckZ1bGwgPSBmYWxzZTtcbiAgICB0aGlzLmlucHV0UGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5yZWNlaXZlZERhdGFIYW5kbGVyID0gdGhpcy5wcm9jZXNzUmVjZWl2ZWREYXRhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2xvc2VUaW1lckhhbmRsZXIgPSB0aGlzLmhhbmRsZUNsb3NlVGltZXIuYmluZCh0aGlzKTtcblxuICAgIC8vIERpc2FibGUgbmFnbGUgYWxnb3JpdGhtP1xuICAgIHRoaXMuc29ja2V0LnNldE5vRGVsYXkodGhpcy5jb25maWcuZGlzYWJsZU5hZ2xlQWxnb3JpdGhtKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBubyBzb2NrZXQgaW5hY3Rpdml0eSB0aW1lb3V0XG4gICAgdGhpcy5zb2NrZXQuc2V0VGltZW91dCgwKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5rZWVwYWxpdmUgJiYgIXRoaXMuY29uZmlnLnVzZU5hdGl2ZUtlZXBhbGl2ZSkge1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuY29uZmlnLmtlZXBhbGl2ZUludGVydmFsKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna2VlcGFsaXZlSW50ZXJ2YWwgbXVzdCBiZSBzcGVjaWZpZWQgYW5kIG51bWVyaWMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lmIGtlZXBhbGl2ZSBpcyB0cnVlLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2tlZXBhbGl2ZVRpbWVySGFuZGxlciA9IHRoaXMuaGFuZGxlS2VlcGFsaXZlVGltZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRLZWVwYWxpdmVUaW1lcigpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5kcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZih0aGlzLmNvbmZpZy5rZWVwYWxpdmVHcmFjZVBlcmlvZCkgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdrZWVwYWxpdmVHcmFjZVBlcmlvZCAgbXVzdCBiZSBzcGVjaWZpZWQgYW5kICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbnVtZXJpYyBpZiBkcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lzIHRydWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ncmFjZVBlcmlvZFRpbWVySGFuZGxlciA9IHRoaXMuaGFuZGxlR3JhY2VQZXJpb2RUaW1lci5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuY29uZmlnLmtlZXBhbGl2ZSAmJiB0aGlzLmNvbmZpZy51c2VOYXRpdmVLZWVwYWxpdmUpIHtcbiAgICAgICAgaWYgKCEoJ3NldEtlZXBBbGl2ZScgaW4gdGhpcy5zb2NrZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byB1c2UgbmF0aXZlIGtlZXBhbGl2ZTogdW5zdXBwb3J0ZWQgYnkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RoaXMgdmVyc2lvbiBvZiBOb2RlLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0LnNldEtlZXBBbGl2ZSh0cnVlLCB0aGlzLmNvbmZpZy5rZWVwYWxpdmVJbnRlcnZhbCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFRoZSBIVFRQIENsaWVudCBzZWVtcyB0byBzdWJzY3JpYmUgdG8gc29ja2V0IGVycm9yIGV2ZW50c1xuICAgIC8vIGFuZCByZS1kaXNwYXRjaCB0aGVtIGluIHN1Y2ggYSB3YXkgdGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2VcbiAgICAvLyBmb3IgdXNlcnMgb2Ygb3VyIGNsaWVudCwgc28gd2Ugd2FudCB0byBtYWtlIHN1cmUgbm9ib2R5XG4gICAgLy8gZWxzZSBpcyBsaXN0ZW5pbmcgZm9yIGVycm9yIGV2ZW50cyBvbiB0aGUgc29ja2V0IGJlc2lkZXMgdXMuXG4gICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpO1xufVxuXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1JNQUwgPSAxMDAwO1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fR09JTkdfQVdBWSA9IDEwMDE7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUiA9IDEwMDI7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9VTlBST0NFU1NBQkxFX0lOUFVUID0gMTAwMztcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1JFU0VSVkVEID0gMTAwNDsgLy8gUmVzZXJ2ZWQgdmFsdWUuICBVbmRlZmluZWQgbWVhbmluZy5cbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX05PVF9QUk9WSURFRCA9IDEwMDU7IC8vIE5vdCB0byBiZSB1c2VkIG9uIHRoZSB3aXJlXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9BQk5PUk1BTCA9IDEwMDY7IC8vIE5vdCB0byBiZSB1c2VkIG9uIHRoZSB3aXJlXG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlZBTElEX0RBVEEgPSAxMDA3O1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUE9MSUNZX1ZJT0xBVElPTiA9IDEwMDg7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9NRVNTQUdFX1RPT19CSUcgPSAxMDA5O1xuV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fRVhURU5TSU9OX1JFUVVJUkVEID0gMTAxMDtcbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0lOVEVSTkFMX1NFUlZFUl9FUlJPUiA9IDEwMTE7XG5XZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9UTFNfSEFORFNIQUtFX0ZBSUxFRCA9IDEwMTU7IC8vIE5vdCB0byBiZSB1c2VkIG9uIHRoZSB3aXJlXG5cbldlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfREVTQ1JJUFRJT05TID0ge1xuICAgIDEwMDA6ICdOb3JtYWwgY29ubmVjdGlvbiBjbG9zdXJlJyxcbiAgICAxMDAxOiAnUmVtb3RlIHBlZXIgaXMgZ29pbmcgYXdheScsXG4gICAgMTAwMjogJ1Byb3RvY29sIGVycm9yJyxcbiAgICAxMDAzOiAnVW5wcm9jZXNzYWJsZSBpbnB1dCcsXG4gICAgMTAwNDogJ1Jlc2VydmVkJyxcbiAgICAxMDA1OiAnUmVhc29uIG5vdCBwcm92aWRlZCcsXG4gICAgMTAwNjogJ0Fibm9ybWFsIGNsb3N1cmUsIG5vIGZ1cnRoZXIgZGV0YWlsIGF2YWlsYWJsZScsXG4gICAgMTAwNzogJ0ludmFsaWQgZGF0YSByZWNlaXZlZCcsXG4gICAgMTAwODogJ1BvbGljeSB2aW9sYXRpb24nLFxuICAgIDEwMDk6ICdNZXNzYWdlIHRvbyBiaWcnLFxuICAgIDEwMTA6ICdFeHRlbnNpb24gcmVxdWVzdGVkIGJ5IGNsaWVudCBpcyByZXF1aXJlZCcsXG4gICAgMTAxMTogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgMTAxNTogJ1RMUyBIYW5kc2hha2UgRmFpbGVkJ1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVDbG9zZVJlYXNvbihjb2RlKSB7XG4gICAgaWYgKGNvZGUgPCAxMDAwKSB7XG4gICAgICAgIC8vIFN0YXR1cyBjb2RlcyBpbiB0aGUgcmFuZ2UgMC05OTkgYXJlIG5vdCB1c2VkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDI5OTkpIHtcbiAgICAgICAgLy8gQ29kZXMgZnJvbSAxMDAwIC0gMjk5OSBhcmUgcmVzZXJ2ZWQgZm9yIHVzZSBieSB0aGUgcHJvdG9jb2wuICBPbmx5XG4gICAgICAgIC8vIGEgZmV3IGNvZGVzIGFyZSBkZWZpbmVkLCBhbGwgb3RoZXJzIGFyZSBjdXJyZW50bHkgaWxsZWdhbC5cbiAgICAgICAgcmV0dXJuIFsxMDAwLCAxMDAxLCAxMDAyLCAxMDAzLCAxMDA3LCAxMDA4LCAxMDA5LCAxMDEwLCAxMDExLCAxMDEyLCAxMDEzLCAxMDE0LCAxMDE1XS5pbmRleE9mKGNvZGUpICE9PSAtMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDM5OTkpIHtcbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIHVzZSBieSBsaWJyYXJpZXMsIGZyYW1ld29ya3MsIGFuZCBhcHBsaWNhdGlvbnMuXG4gICAgICAgIC8vIFNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggSUFOQS4gIEludGVycHJldGF0aW9uIG9mIHRoZXNlIGNvZGVzIGlzXG4gICAgICAgIC8vIHVuZGVmaW5lZCBieSB0aGUgV2ViU29ja2V0IHByb3RvY29sLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gNDAwMCAmJiBjb2RlIDw9IDQ5OTkpIHtcbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIHByaXZhdGUgdXNlLiAgSW50ZXJwcmV0YXRpb24gb2YgdGhlc2UgY29kZXMgaXNcbiAgICAgICAgLy8gdW5kZWZpbmVkIGJ5IHRoZSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSA1MDAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0Q29ubmVjdGlvbiwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuX2FkZFNvY2tldEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Vycm9yJywgdGhpcy5oYW5kbGVTb2NrZXRFcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbignZW5kJywgdGhpcy5oYW5kbGVTb2NrZXRFbmQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5oYW5kbGVTb2NrZXRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnNvY2tldC5vbignZHJhaW4nLCB0aGlzLmhhbmRsZVNvY2tldERyYWluLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdwYXVzZScsIHRoaXMuaGFuZGxlU29ja2V0UGF1c2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ3Jlc3VtZScsIHRoaXMuaGFuZGxlU29ja2V0UmVzdW1lLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc29ja2V0Lm9uKCdkYXRhJywgdGhpcy5oYW5kbGVTb2NrZXREYXRhLmJpbmQodGhpcykpO1xufTtcblxuLy8gc2V0IG9yIHJlc2V0IHRoZSBrZWVwYWxpdmUgdGltZXIgd2hlbiBkYXRhIGlzIHJlY2VpdmVkLlxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2V0S2VlcGFsaXZlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2V0S2VlcGFsaXZlVGltZXInKTtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmtlZXBhbGl2ZSAgfHwgdGhpcy5jb25maWcudXNlTmF0aXZlS2VlcGFsaXZlKSB7IHJldHVybjsgfVxuICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lcigpO1xuICAgIHRoaXMuY2xlYXJHcmFjZVBlcmlvZFRpbWVyKCk7XG4gICAgdGhpcy5fa2VlcGFsaXZlVGltZW91dElEID0gc2V0VGltZW91dCh0aGlzLl9rZWVwYWxpdmVUaW1lckhhbmRsZXIsIHRoaXMuY29uZmlnLmtlZXBhbGl2ZUludGVydmFsKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmNsZWFyS2VlcGFsaXZlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fa2VlcGFsaXZlVGltZW91dElEKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9rZWVwYWxpdmVUaW1lb3V0SUQpO1xuICAgIH1cbn07XG5cbi8vIE5vIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQgd2l0aGluIGNvbmZpZy5rZWVwYWxpdmVUaW1lb3V0IG1zLlxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlS2VlcGFsaXZlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlS2VlcGFsaXZlVGltZXInKTtcbiAgICB0aGlzLl9rZWVwYWxpdmVUaW1lb3V0SUQgPSBudWxsO1xuICAgIHRoaXMucGluZygpO1xuXG4gICAgLy8gSWYgd2UgYXJlIGNvbmZpZ3VyZWQgdG8gZHJvcCBjb25uZWN0aW9ucyBpZiB0aGUgY2xpZW50IGRvZXNuJ3QgcmVzcG9uZFxuICAgIC8vIHRoZW4gc2V0IHRoZSBncmFjZSBwZXJpb2QgdGltZXIuXG4gICAgaWYgKHRoaXMuY29uZmlnLmRyb3BDb25uZWN0aW9uT25LZWVwYWxpdmVUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuc2V0R3JhY2VQZXJpb2RUaW1lcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IHRoZSBrZWVwYWxpdmUgdGltZXIgdG8gc2VuZCB0aGUgbmV4dCBwaW5nLlxuICAgICAgICB0aGlzLnNldEtlZXBhbGl2ZVRpbWVyKCk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2V0R3JhY2VQZXJpb2RUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdzZXRHcmFjZVBlcmlvZFRpbWVyJyk7XG4gICAgdGhpcy5jbGVhckdyYWNlUGVyaW9kVGltZXIoKTtcbiAgICB0aGlzLl9ncmFjZVBlcmlvZFRpbWVvdXRJRCA9IHNldFRpbWVvdXQodGhpcy5fZ3JhY2VQZXJpb2RUaW1lckhhbmRsZXIsIHRoaXMuY29uZmlnLmtlZXBhbGl2ZUdyYWNlUGVyaW9kKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmNsZWFyR3JhY2VQZXJpb2RUaW1lciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ncmFjZVBlcmlvZFRpbWVvdXRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZ3JhY2VQZXJpb2RUaW1lb3V0SUQpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZUdyYWNlUGVyaW9kVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlR3JhY2VQZXJpb2RUaW1lcicpO1xuICAgIC8vIElmIHRoaXMgaXMgY2FsbGVkLCB0aGUgY2xpZW50IGhhcyBub3QgcmVzcG9uZGVkIGFuZCBpcyBhc3N1bWVkIGRlYWQuXG4gICAgdGhpcy5fZ3JhY2VQZXJpb2RUaW1lb3V0SUQgPSBudWxsO1xuICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9BQk5PUk1BTCwgJ1BlZXIgbm90IHJlc3BvbmRpbmcuJywgdHJ1ZSk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXREYXRhJyk7XG4gICAgLy8gUmVzZXQgdGhlIGtlZXBhbGl2ZSB0aW1lciB3aGVuIHJlY2VpdmluZyBkYXRhIG9mIGFueSBraW5kLlxuICAgIHRoaXMuc2V0S2VlcGFsaXZlVGltZXIoKTtcblxuICAgIC8vIEFkZCByZWNlaXZlZCBkYXRhIHRvIG91ciBidWZmZXJMaXN0LCB3aGljaCBlZmZpY2llbnRseSBob2xkcyByZWNlaXZlZFxuICAgIC8vIGRhdGEgY2h1bmtzIGluIGEgbGlua2VkIGxpc3Qgb2YgQnVmZmVyIG9iamVjdHMuXG4gICAgdGhpcy5idWZmZXJMaXN0LndyaXRlKGRhdGEpO1xuXG4gICAgdGhpcy5wcm9jZXNzUmVjZWl2ZWREYXRhKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5wcm9jZXNzUmVjZWl2ZWREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ3Byb2Nlc3NSZWNlaXZlZERhdGEnKTtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCB3ZSBzaG91bGQgaWdub3JlIGFueSBkYXRhIHJlbWFpbmluZyBvbiB0aGUgYnVmZmVyLlxuICAgIGlmICghdGhpcy5jb25uZWN0ZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAvLyBSZWNlaXZpbmcvcGFyc2luZyBpcyBleHBlY3RlZCB0byBiZSBoYWx0ZWQgd2hlbiBwYXVzZWQuXG4gICAgaWYgKHRoaXMuaW5wdXRQYXVzZWQpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgZnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcblxuICAgIC8vIFdlYlNvY2tldEZyYW1lLnByb3RvdHlwZS5hZGREYXRhIHJldHVybnMgdHJ1ZSBpZiBhbGwgZGF0YSBuZWNlc3NhcnkgdG9cbiAgICAvLyBwYXJzZSB0aGUgZnJhbWUgd2FzIGF2YWlsYWJsZS4gIEl0IHJldHVybnMgZmFsc2UgaWYgd2UgYXJlIHdhaXRpbmcgZm9yXG4gICAgLy8gbW9yZSBkYXRhIHRvIGNvbWUgaW4gb24gdGhlIHdpcmUuXG4gICAgaWYgKCFmcmFtZS5hZGREYXRhKHRoaXMuYnVmZmVyTGlzdCkpIHsgdGhpcy5fZGVidWcoJy0tIGluc3VmZmljaWVudCBkYXRhIGZvciBmcmFtZScpOyByZXR1cm47IH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIEhhbmRsZSBwb3NzaWJsZSBwYXJzaW5nIGVycm9yc1xuICAgIGlmIChmcmFtZS5wcm90b2NvbEVycm9yKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyBiYWQgaGFwcGVuZWQuLiBnZXQgcmlkIG9mIHRoaXMgY2xpZW50LlxuICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gcHJvdG9jb2wgZXJyb3InKTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUiwgZnJhbWUuZHJvcFJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGZyYW1lLmZyYW1lVG9vTGFyZ2UpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIGZyYW1lIHRvbyBsYXJnZScpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX01FU1NBR0VfVE9PX0JJRywgZnJhbWUuZHJvcFJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRm9yIG5vdyBzaW5jZSB3ZSBkb24ndCBzdXBwb3J0IGV4dGVuc2lvbnMsIGFsbCBSU1YgYml0cyBhcmUgaWxsZWdhbFxuICAgIGlmIChmcmFtZS5yc3YxIHx8IGZyYW1lLnJzdjIgfHwgZnJhbWUucnN2Mykge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gaWxsZWdhbCByc3YgZmxhZycpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICAgICAnVW5zdXBwb3J0ZWQgdXNhZ2Ugb2YgcnN2IGJpdHMgd2l0aG91dCBuZWdvdGlhdGVkIGV4dGVuc2lvbi4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYXNzZW1ibGVGcmFnbWVudHMpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIGVtaXR0aW5nIGZyYW1lJyk7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYuZW1pdCgnZnJhbWUnLCBmcmFtZSk7IH0pO1xuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYucHJvY2Vzc0ZyYW1lKGZyYW1lKTsgfSk7XG4gICAgXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcblxuICAgIC8vIElmIHRoZXJlJ3MgZGF0YSByZW1haW5pbmcsIHNjaGVkdWxlIGFkZGl0aW9uYWwgcHJvY2Vzc2luZywgYnV0IHlpZWxkXG4gICAgLy8gZm9yIG5vdyBzbyB0aGF0IG90aGVyIGNvbm5lY3Rpb25zIGhhdmUgYSBjaGFuY2UgdG8gaGF2ZSB0aGVpciBkYXRhXG4gICAgLy8gcHJvY2Vzc2VkLiAgV2UgdXNlIHNldEltbWVkaWF0ZSBoZXJlIGluc3RlYWQgb2YgcHJvY2Vzcy5uZXh0VGljayB0b1xuICAgIC8vIGV4cGxpY2l0bHkgaW5kaWNhdGUgdGhhdCB3ZSB3aXNoIGZvciBvdGhlciBJL08gdG8gYmUgaGFuZGxlZCBmaXJzdC5cbiAgICBpZiAodGhpcy5idWZmZXJMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlSW1wbCh0aGlzLnJlY2VpdmVkRGF0YUhhbmRsZXIpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldEVycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0RXJyb3I6ICVqJywgZXJyb3IpO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9DTE9TRUQpIHtcblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlL2lzc3Vlcy8yODhcbiAgICAgICAgdGhpcy5fZGVidWcoJyAgLS0tIFNvY2tldCBcXCdlcnJvclxcJyBhZnRlciBcXCdjbG9zZVxcJycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUw7XG4gICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gJ1NvY2tldCBFcnJvcjogJyArIGVycm9yLnN5c2NhbGwgKyAnICcgKyBlcnJvci5jb2RlO1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gMDtcbiAgICBpZiAodXRpbHMuZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpO1xuICAgIHRoaXMuX2RlYnVnLnByaW50T3V0cHV0KCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRFbmQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnaGFuZGxlU29ja2V0RW5kOiByZWNlaXZlZCBzb2NrZXQgZW5kLiAgc3RhdGUgPSAlcycsIHRoaXMuc3RhdGUpO1xuICAgIHRoaXMucmVjZWl2ZWRFbmQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9DTE9TRUQpIHtcbiAgICAgICAgLy8gV2hlbiB1c2luZyB0aGUgVExTIG1vZHVsZSwgc29tZXRpbWVzIHRoZSBzb2NrZXQgd2lsbCBlbWl0ICdlbmQnXG4gICAgICAgIC8vIGFmdGVyIGl0IGVtaXRzICdjbG9zZScuICBJIGRvbid0IHRoaW5rIHRoYXQncyBjb3JyZWN0IGJlaGF2aW9yLFxuICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIGRlYWwgd2l0aCBpdCBncmFjZWZ1bGx5IGJ5IGlnbm9yaW5nIGl0LlxuICAgICAgICB0aGlzLl9kZWJ1ZygnICAtLS0gU29ja2V0IFxcJ2VuZFxcJyBhZnRlciBcXCdjbG9zZVxcJycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9QRUVSX1JFUVVFU1RFRF9DTE9TRSAmJlxuICAgICAgICB0aGlzLnN0YXRlICE9PSBTVEFURV9FTkRJTkcpIHtcbiAgICAgIHRoaXMuX2RlYnVnKCcgIC0tLSBVTkVYUEVDVEVEIHNvY2tldCBlbmQuJyk7XG4gICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRDbG9zZSA9IGZ1bmN0aW9uKGhhZEVycm9yKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldENsb3NlOiByZWNlaXZlZCBzb2NrZXQgY2xvc2UnKTtcbiAgICB0aGlzLnNvY2tldEhhZEVycm9yID0gaGFkRXJyb3I7XG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfQ0xPU0VEO1xuICAgIC8vIElmIGNsb3NlUmVhc29uQ29kZSBpcyBzdGlsbCBzZXQgdG8gLTEgYXQgdGhpcyBwb2ludCB0aGVuIHdlIG11c3RcbiAgICAvLyBub3QgaGF2ZSByZWNlaXZlZCBhIGNsb3NlIGZyYW1lISFcbiAgICBpZiAodGhpcy5jbG9zZVJlYXNvbkNvZGUgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fQUJOT1JNQUw7XG4gICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9ICdDb25uZWN0aW9uIGRyb3BwZWQgYnkgcmVtb3RlIHBlZXIuJztcbiAgICB9XG4gICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyR3JhY2VQZXJpb2RUaW1lcigpO1xuICAgIGlmICghdGhpcy5jbG9zZUV2ZW50RW1pdHRlZCkge1xuICAgICAgICB0aGlzLmNsb3NlRXZlbnRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVidWcoJy0tIEVtaXR0aW5nIFdlYlNvY2tldENvbm5lY3Rpb24gY2xvc2UgZXZlbnQnKTtcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuY2xvc2VSZWFzb25Db2RlLCB0aGlzLmNsb3NlRGVzY3JpcHRpb24pO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZVNvY2tldERyYWluID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldERyYWluOiBzb2NrZXQgZHJhaW4gZXZlbnQnKTtcbiAgICB0aGlzLm91dHB1dEJ1ZmZlckZ1bGwgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVTb2NrZXRQYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlYnVnKCdoYW5kbGVTb2NrZXRQYXVzZTogc29ja2V0IHBhdXNlIGV2ZW50Jyk7XG4gICAgdGhpcy5pbnB1dFBhdXNlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlU29ja2V0UmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZVNvY2tldFJlc3VtZTogc29ja2V0IHJlc3VtZSBldmVudCcpO1xuICAgIHRoaXMuaW5wdXRQYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICAgIHRoaXMucHJvY2Vzc1JlY2VpdmVkRGF0YSgpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygncGF1c2U6IHBhdXNlIHJlcXVlc3RlZCcpO1xuICAgIHRoaXMuc29ja2V0LnBhdXNlKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygncmVzdW1lOiByZXN1bWUgcmVxdWVzdGVkJyk7XG4gICAgdGhpcy5zb2NrZXQucmVzdW1lKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdjbG9zZTogSW5pdGF0aW5nIGNsZWFuIFdlYlNvY2tldCBjbG9zZSBzZXF1ZW5jZS4nKTtcbiAgICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgcmVhc29uQ29kZSkge1xuICAgICAgICAgICAgcmVhc29uQ29kZSA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX05PUk1BTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbGlkYXRlQ2xvc2VSZWFzb24ocmVhc29uQ29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xvc2UgY29kZSAnICsgcmVhc29uQ29kZSArICcgaXMgbm90IHZhbGlkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfREVTQ1JJUFRJT05TW3JlYXNvbkNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gcmVhc29uQ29kZTtcbiAgICAgICAgdGhpcy5jbG9zZURlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuc2V0Q2xvc2VUaW1lcigpO1xuICAgICAgICB0aGlzLnNlbmRDbG9zZUZyYW1lKHRoaXMuY2xvc2VSZWFzb25Db2RlLCB0aGlzLmNsb3NlRGVzY3JpcHRpb24pO1xuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRU5ESU5HO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbihyZWFzb25Db2RlLCBkZXNjcmlwdGlvbiwgc2tpcENsb3NlRnJhbWUpIHtcbiAgICB0aGlzLl9kZWJ1ZygnZHJvcCcpO1xuICAgIGlmICh0eXBlb2YocmVhc29uQ29kZSkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mKGRlc2NyaXB0aW9uKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSWYgbm8gZGVzY3JpcHRpb24gaXMgcHJvdmlkZWQsIHRyeSB0byBsb29rIG9uZSB1cCBiYXNlZCBvbiB0aGVcbiAgICAgICAgLy8gc3BlY2lmaWVkIHJlYXNvbkNvZGUuXG4gICAgICAgIGRlc2NyaXB0aW9uID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9ERVNDUklQVElPTlNbcmVhc29uQ29kZV07XG4gICAgfVxuXG4gICAgdGhpcy5fZGVidWcoJ0ZvcmNlZnVsbHkgZHJvcHBpbmcgY29ubmVjdGlvbi4gc2tpcENsb3NlRnJhbWU6ICVzLCBjb2RlOiAlZCwgZGVzY3JpcHRpb246ICVzJyxcbiAgICAgICAgc2tpcENsb3NlRnJhbWUsIHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uXG4gICAgKTtcblxuICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gcmVhc29uQ29kZTtcbiAgICB0aGlzLmNsb3NlRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB0aGlzLmZyYW1lUXVldWUgPSBbXTtcbiAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gMDtcbiAgICBpZiAoIXNraXBDbG9zZUZyYW1lKSB7XG4gICAgICAgIHRoaXMuc2VuZENsb3NlRnJhbWUocmVhc29uQ29kZSwgZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUgPSBTVEFURV9DTE9TRUQ7XG4gICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZXIoKTtcbiAgICB0aGlzLmNsZWFyR3JhY2VQZXJpb2RUaW1lcigpO1xuXG4gICAgaWYgKCF0aGlzLmNsb3NlRXZlbnRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFdmVudEVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnRW1pdHRpbmcgV2ViU29ja2V0Q29ubmVjdGlvbiBjbG9zZSBldmVudCcpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5jbG9zZVJlYXNvbkNvZGUsIHRoaXMuY2xvc2VEZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuX2RlYnVnKCdEcm9wOiBkZXN0cm95aW5nIHNvY2tldCcpO1xuICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNldENsb3NlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2V0Q2xvc2VUaW1lcicpO1xuICAgIHRoaXMuY2xlYXJDbG9zZVRpbWVyKCk7XG4gICAgdGhpcy5fZGVidWcoJ1NldHRpbmcgY2xvc2UgdGltZXInKTtcbiAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gdHJ1ZTtcbiAgICB0aGlzLmNsb3NlVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX2Nsb3NlVGltZXJIYW5kbGVyLCB0aGlzLmNsb3NlVGltZW91dCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbGVhckNsb3NlVGltZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9kZWJ1ZygnY2xlYXJDbG9zZVRpbWVyJyk7XG4gICAgaWYgKHRoaXMuY2xvc2VUaW1lcikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnQ2xlYXJpbmcgY2xvc2UgdGltZXInKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VUaW1lcik7XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5oYW5kbGVDbG9zZVRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVidWcoJ2hhbmRsZUNsb3NlVGltZXInKTtcbiAgICB0aGlzLmNsb3NlVGltZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdDbG9zZSByZXNwb25zZSBub3QgcmVjZWl2ZWQgZnJvbSBjbGllbnQuICBGb3JjaW5nIHNvY2tldCBlbmQuJyk7XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvckNsb3NlUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICAgICAgdGhpcy5zb2NrZXQuZW5kKCk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucHJvY2Vzc0ZyYW1lID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICB0aGlzLl9kZWJ1ZygncHJvY2Vzc0ZyYW1lJyk7XG4gICAgdGhpcy5fZGVidWcoJyAtLSBmcmFtZTogJXMnLCBmcmFtZSk7XG4gICAgXG4gICAgLy8gQW55IG5vbi1jb250cm9sIG9wY29kZSBiZXNpZGVzIDB4MDAgKGNvbnRpbnVhdGlvbikgcmVjZWl2ZWQgaW4gdGhlXG4gICAgLy8gbWlkZGxlIG9mIGEgZnJhZ21lbnRlZCBtZXNzYWdlIGlzIGlsbGVnYWwuXG4gICAgaWYgKHRoaXMuZnJhbWVRdWV1ZS5sZW5ndGggIT09IDAgJiYgKGZyYW1lLm9wY29kZSA+IDB4MDAgJiYgZnJhbWUub3Bjb2RlIDwgMHgwOCkpIHtcbiAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICdJbGxlZ2FsIGZyYW1lIG9wY29kZSAweCcgKyBmcmFtZS5vcGNvZGUudG9TdHJpbmcoMTYpICsgJyAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgaW4gbWlkZGxlIG9mIGZyYWdtZW50ZWQgbWVzc2FnZS4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaChmcmFtZS5vcGNvZGUpIHtcbiAgICAgICAgY2FzZSAweDAyOiAvLyBXZWJTb2NrZXRGcmFtZS5CSU5BUllfRlJBTUVcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBCaW5hcnkgRnJhbWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2VtYmxlRnJhZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLmZpbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wbGV0ZSBzaW5nbGUtZnJhbWUgbWVzc2FnZSByZWNlaXZlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0tLSBFbWl0dGluZyBcXCdtZXNzYWdlXFwnIGV2ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdiaW5hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5RGF0YTogZnJhbWUuYmluYXJ5UGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiBhIGZyYWdtZW50ZWQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUucHVzaChmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRhdGlvblNpemUgPSBmcmFtZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwMTogLy8gV2ViU29ja2V0RnJhbWUuVEVYVF9GUkFNRVxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tIFRleHQgRnJhbWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2VtYmxlRnJhZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lLmZpbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGZyYW1lLmJpbmFyeVBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fSU5WQUxJRF9EQVRBLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBVVEYtOCBEYXRhIFJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGxldGUgc2luZ2xlLWZyYW1lIG1lc3NhZ2UgcmVjZWl2ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0gRW1pdHRpbmcgXFwnbWVzc2FnZVxcJyBldmVudCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXRmOCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGY4RGF0YTogZnJhbWUuYmluYXJ5UGF5bG9hZC50b1N0cmluZygndXRmOCcpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIGEgZnJhZ21lbnRlZCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVRdWV1ZS5wdXNoKGZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA9IGZyYW1lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDAwOiAvLyBXZWJTb2NrZXRGcmFtZS5DT05USU5VQVRJT05cbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBDb250aW51YXRpb24gRnJhbWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFzc2VtYmxlRnJhZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICdVbmV4cGVjdGVkIENvbnRpbnVhdGlvbiBGcmFtZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudGF0aW9uU2l6ZSArPSBmcmFtZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mcmFnbWVudGF0aW9uU2l6ZSA+IHRoaXMubWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AoV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fTUVTU0FHRV9UT09fQklHLFxuICAgICAgICAgICAgICAgICAgICAgICdNYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBleGNlZWRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVRdWV1ZS5wdXNoKGZyYW1lKTtcblxuICAgICAgICAgICAgICAgIGlmIChmcmFtZS5maW4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5kIG9mIGZyYWdtZW50ZWQgbWVzc2FnZSwgc28gd2UgcHJvY2VzcyB0aGUgd2hvbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVzc2FnZSBub3cuICBXZSBhbHNvIGhhdmUgdG8gZGVjb2RlIHRoZSB1dGYtOCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciB0ZXh0IGZyYW1lcyBhZnRlciBjb21iaW5pbmcgYWxsIHRoZSBmcmFnbWVudHMuXG4gICAgICAgICAgICAgICAgICAgIHZhciBieXRlc0NvcGllZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5hcnlQYXlsb2FkID0gYnVmZmVyQWxsb2NVbnNhZmUodGhpcy5mcmFnbWVudGF0aW9uU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGNvZGUgPSB0aGlzLmZyYW1lUXVldWVbMF0ub3Bjb2RlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYW1lUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuYmluYXJ5UGF5bG9hZC5jb3B5KGJpbmFyeVBheWxvYWQsIGJ5dGVzQ29waWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzQ29waWVkICs9IGN1cnJlbnRGcmFtZS5iaW5hcnlQYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50YXRpb25TaXplID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAyOiAvLyBXZWJTb2NrZXRPcGNvZGUuQklOQVJZX0ZSQU1FXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmluYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5RGF0YTogYmluYXJ5UGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAweDAxOiAvLyBXZWJTb2NrZXRPcGNvZGUuVEVYVF9GUkFNRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZFVURjgoYmluYXJ5UGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0lOVkFMSURfREFUQSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBVVEYtOCBEYXRhIFJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndXRmOCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhEYXRhOiBiaW5hcnlQYXlsb2FkLnRvU3RyaW5nKCd1dGY4JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wKFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX1BST1RPQ09MX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VuZXhwZWN0ZWQgZmlyc3Qgb3Bjb2RlIGluIGZyYWdtZW50YXRpb24gc2VxdWVuY2U6IDB4JyArIG9wY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MDk6IC8vIFdlYlNvY2tldEZyYW1lLlBJTkdcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBQaW5nIEZyYW1lJyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9waW5nTGlzdGVuZXJDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBsb2dpYyB0byBlbWl0IHRoZSBwaW5nIGZyYW1lOiB0aGlzIGlzIG9ubHkgZG9uZSB3aGVuIGEgbGlzdGVuZXIgaXMga25vd24gdG8gZXhpc3RcbiAgICAgICAgICAgICAgICAvLyBFeHBvc2UgYSBmdW5jdGlvbiBhbGxvd2luZyB0aGUgdXNlciB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBwaW5nKCkgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICB2YXIgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7IFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwaW5nJywgY2FuY2VsLCBmcmFtZS5iaW5hcnlQYXlsb2FkKTtcblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgc2VuZCBhIHBvbmcgaWYgdGhlIGNsaWVudCBkaWQgbm90IGluZGljYXRlIHRoYXQgaGUgd291bGQgbGlrZSB0byBjYW5jZWxcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbmcoZnJhbWUuYmluYXJ5UGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb25nKGZyYW1lLmJpbmFyeVBheWxvYWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDBBOiAvLyBXZWJTb2NrZXRGcmFtZS5QT05HXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gUG9uZyBGcmFtZScpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwb25nJywgZnJhbWUuYmluYXJ5UGF5bG9hZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDA4OiAvLyBXZWJTb2NrZXRGcmFtZS5DT05ORUNUSU9OX0NMT1NFXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnLS0gQ2xvc2UgRnJhbWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgLy8gR290IHJlc3BvbnNlIHRvIG91ciByZXF1ZXN0IHRvIGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIENsb3NlIGlzIGNvbXBsZXRlLCBzbyB3ZSBqdXN0IGhhbmcgdXAuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0gR290IGNsb3NlIHJlc3BvbnNlIGZyb20gcGVlci4gIENvbXBsZXRpbmcgY2xvc2luZyBoYW5kc2hha2UuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckNsb3NlVGltZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXRpbmdGb3JDbG9zZVJlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0NMT1NFRDtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLS0tIENsb3NpbmcgaGFuZHNoYWtlIGluaXRpYXRlZCBieSBwZWVyLicpO1xuICAgICAgICAgICAgLy8gR290IHJlcXVlc3QgZnJvbSBvdGhlciBwYXJ0eSB0byBjbG9zZSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgLy8gU2VuZCBiYWNrIGFja25vd2xlZGdlbWVudCBhbmQgdGhlbiBoYW5nIHVwLlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BFRVJfUkVRVUVTVEVEX0NMT1NFO1xuICAgICAgICAgICAgdmFyIHJlc3BvbmRDbG9zZVJlYXNvbkNvZGU7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2xvc2UgcmVhc29uIHByb3ZpZGVkIGlzIGxlZ2FsIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gdGhlIHByb3RvY29sIHNwZWMuICBQcm92aWRpbmcgbm8gY2xvc2Ugc3RhdHVzIGlzIGxlZ2FsLlxuICAgICAgICAgICAgLy8gV2ViU29ja2V0RnJhbWUgc2V0cyBjbG9zZVN0YXR1cyB0byAtMSBieSBkZWZhdWx0LCBzbyBpZiBpdFxuICAgICAgICAgICAgLy8gaXMgc3RpbGwgLTEsIHRoZW4gbm8gc3RhdHVzIHdhcyBwcm92aWRlZC5cbiAgICAgICAgICAgIGlmIChmcmFtZS5pbnZhbGlkQ2xvc2VGcmFtZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VSZWFzb25Db2RlID0gMTAwNTsgLy8gMTAwNSA9IE5vIHJlYXNvbiBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICByZXNwb25kQ2xvc2VSZWFzb25Db2RlID0gV2ViU29ja2V0Q29ubmVjdGlvbi5DTE9TRV9SRUFTT05fUFJPVE9DT0xfRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFtZS5jbG9zZVN0YXR1cyA9PT0gLTEgfHwgdmFsaWRhdGVDbG9zZVJlYXNvbihmcmFtZS5jbG9zZVN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IGZyYW1lLmNsb3NlU3RhdHVzO1xuICAgICAgICAgICAgICAgIHJlc3BvbmRDbG9zZVJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1JNQUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUmVhc29uQ29kZSA9IGZyYW1lLmNsb3NlU3RhdHVzO1xuICAgICAgICAgICAgICAgIHJlc3BvbmRDbG9zZVJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB0ZXh0dWFsIGRlc2NyaXB0aW9uIGluIHRoZSBjbG9zZSBmcmFtZSwgZXh0cmFjdCBpdC5cbiAgICAgICAgICAgIGlmIChmcmFtZS5iaW5hcnlQYXlsb2FkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRVVEY4KGZyYW1lLmJpbmFyeVBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9JTlZBTElEX0RBVEEsXG4gICAgICAgICAgICAgICAgICAgICAgJ0ludmFsaWQgVVRGLTggRGF0YSBSZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IGZyYW1lLmJpbmFyeVBheWxvYWQudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiA9IFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfREVTQ1JJUFRJT05TW3RoaXMuY2xvc2VSZWFzb25Db2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKFxuICAgICAgICAgICAgICAgICctLS0tLS0gUmVtb3RlIHBlZXIgJXMgLSBjb2RlOiAlZCAtICVzIC0gY2xvc2UgZnJhbWUgcGF5bG9hZCBsZW5ndGg6ICVkJyxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MsIHRoaXMuY2xvc2VSZWFzb25Db2RlLFxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VEZXNjcmlwdGlvbiwgZnJhbWUubGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJy0tLS0tLSByZXNwb25kaW5nIHRvIHJlbW90ZSBwZWVyXFwncyBjbG9zZSByZXF1ZXN0LicpO1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2xvc2VGcmFtZShyZXNwb25kQ2xvc2VSZWFzb25Db2RlLCBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCctLSBVbnJlY29nbml6ZWQgT3Bjb2RlICVkJywgZnJhbWUub3Bjb2RlKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcChXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9QUk9UT0NPTF9FUlJPUixcbiAgICAgICAgICAgICAgJ1VucmVjb2duaXplZCBPcGNvZGU6IDB4JyArIGZyYW1lLm9wY29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEsIGNiKSB7XG4gICAgdGhpcy5fZGVidWcoJ3NlbmQnKTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHRoaXMuc2VuZEJ5dGVzKGRhdGEsIGNiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mKGRhdGFbJ3RvU3RyaW5nJ10pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuc2VuZFVURihkYXRhLCBjYik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgcHJvdmlkZWQgbXVzdCBlaXRoZXIgYmUgYSBOb2RlIEJ1ZmZlciBvciBpbXBsZW1lbnQgdG9TdHJpbmcoKScpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRVVEYgPSBmdW5jdGlvbihkYXRhLCBjYikge1xuICAgIGRhdGEgPSBidWZmZXJGcm9tU3RyaW5nKGRhdGEudG9TdHJpbmcoKSwgJ3V0ZjgnKTtcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZFVURjogJWQgYnl0ZXMnLCBkYXRhLmxlbmd0aCk7XG4gICAgdmFyIGZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgZnJhbWUub3Bjb2RlID0gMHgwMTsgLy8gV2ViU29ja2V0T3Bjb2RlLlRFWFRfRlJBTUVcbiAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gZGF0YTtcbiAgICB0aGlzLmZyYWdtZW50QW5kU2VuZChmcmFtZSwgY2IpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZEJ5dGVzID0gZnVuY3Rpb24oZGF0YSwgY2IpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZEJ5dGVzJyk7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGEgTm9kZSBCdWZmZXIgb2JqZWN0IHRvIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRCeXRlcygpJyk7XG4gICAgfVxuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLm9wY29kZSA9IDB4MDI7IC8vIFdlYlNvY2tldE9wY29kZS5CSU5BUllfRlJBTUVcbiAgICBmcmFtZS5iaW5hcnlQYXlsb2FkID0gZGF0YTtcbiAgICB0aGlzLmZyYWdtZW50QW5kU2VuZChmcmFtZSwgY2IpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLl9kZWJ1ZygncGluZycpO1xuICAgIHZhciBmcmFtZSA9IG5ldyBXZWJTb2NrZXRGcmFtZSh0aGlzLm1hc2tCeXRlcywgdGhpcy5mcmFtZUhlYWRlciwgdGhpcy5jb25maWcpO1xuICAgIGZyYW1lLm9wY29kZSA9IDB4MDk7IC8vIFdlYlNvY2tldE9wY29kZS5QSU5HXG4gICAgZnJhbWUuZmluID0gdHJ1ZTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IGJ1ZmZlckZyb21TdHJpbmcoZGF0YS50b1N0cmluZygpLCAndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEyNSkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ1dlYlNvY2tldDogRGF0YSBmb3IgcGluZyBpcyBsb25nZXIgdGhhbiAxMjUgYnl0ZXMuICBUcnVuY2F0aW5nLicpO1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2UoMCwxMjQpO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lLmJpbmFyeVBheWxvYWQgPSBkYXRhO1xuICAgIH1cbiAgICB0aGlzLnNlbmRGcmFtZShmcmFtZSk7XG59O1xuXG4vLyBQb25nIGZyYW1lcyBoYXZlIHRvIGVjaG8gYmFjayB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgcG9ydGlvbiBvZiB0aGVcbi8vIHBpbmcgZnJhbWUgZXhhY3RseSwgYnl0ZSBmb3IgYnl0ZS5cbldlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnBvbmcgPSBmdW5jdGlvbihiaW5hcnlQYXlsb2FkKSB7XG4gICAgdGhpcy5fZGVidWcoJ3BvbmcnKTtcbiAgICB2YXIgZnJhbWUgPSBuZXcgV2ViU29ja2V0RnJhbWUodGhpcy5tYXNrQnl0ZXMsIHRoaXMuZnJhbWVIZWFkZXIsIHRoaXMuY29uZmlnKTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDBBOyAvLyBXZWJTb2NrZXRPcGNvZGUuUE9OR1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYmluYXJ5UGF5bG9hZCkgJiYgYmluYXJ5UGF5bG9hZC5sZW5ndGggPiAxMjUpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ1dlYlNvY2tldDogRGF0YSBmb3IgcG9uZyBpcyBsb25nZXIgdGhhbiAxMjUgYnl0ZXMuICBUcnVuY2F0aW5nLicpO1xuICAgICAgICBiaW5hcnlQYXlsb2FkID0gYmluYXJ5UGF5bG9hZC5zbGljZSgwLDEyNCk7XG4gICAgfVxuICAgIGZyYW1lLmJpbmFyeVBheWxvYWQgPSBiaW5hcnlQYXlsb2FkO1xuICAgIGZyYW1lLmZpbiA9IHRydWU7XG4gICAgdGhpcy5zZW5kRnJhbWUoZnJhbWUpO1xufTtcblxuV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuZnJhZ21lbnRBbmRTZW5kID0gZnVuY3Rpb24oZnJhbWUsIGNiKSB7XG4gICAgdGhpcy5fZGVidWcoJ2ZyYWdtZW50QW5kU2VuZCcpO1xuICAgIGlmIChmcmFtZS5vcGNvZGUgPiAweDA3KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBmcmFnbWVudCBjb250cm9sIGZyYW1lcy4nKTtcbiAgICB9XG5cbiAgICB2YXIgdGhyZXNob2xkID0gdGhpcy5jb25maWcuZnJhZ21lbnRhdGlvblRocmVzaG9sZDtcbiAgICB2YXIgbGVuZ3RoID0gZnJhbWUuYmluYXJ5UGF5bG9hZC5sZW5ndGg7XG5cbiAgICAvLyBTZW5kIGltbWVkaWF0ZWx5IGlmIGZyYWdtZW50YXRpb24gaXMgZGlzYWJsZWQgb3IgdGhlIG1lc3NhZ2UgaXMgbm90XG4gICAgLy8gbGFyZ2VyIHRoYW4gdGhlIGZyYWdtZW50YXRpb24gdGhyZXNob2xkLlxuICAgIGlmICghdGhpcy5jb25maWcuZnJhZ21lbnRPdXRnb2luZ01lc3NhZ2VzIHx8IChmcmFtZS5iaW5hcnlQYXlsb2FkICYmIGxlbmd0aCA8PSB0aHJlc2hvbGQpKSB7XG4gICAgICAgIGZyYW1lLmZpbiA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VuZEZyYW1lKGZyYW1lLCBjYik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFyIG51bUZyYWdtZW50cyA9IE1hdGguY2VpbChsZW5ndGggLyB0aHJlc2hvbGQpO1xuICAgIHZhciBzZW50RnJhZ21lbnRzID0gMDtcbiAgICB2YXIgc2VudENhbGxiYWNrID0gZnVuY3Rpb24gZnJhZ21lbnRTZW50Q2FsbGJhY2soZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXNzIG9ubHkgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgICAgICBjYiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKytzZW50RnJhZ21lbnRzO1xuICAgICAgICBpZiAoKHNlbnRGcmFnbWVudHMgPT09IG51bUZyYWdtZW50cykgJiYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGk9MTsgaSA8PSBudW1GcmFnbWVudHM7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudEZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIFxuICAgICAgICAvLyBjb250aW51YXRpb24gb3Bjb2RlIGV4Y2VwdCBmb3IgZmlyc3QgZnJhbWUuXG4gICAgICAgIGN1cnJlbnRGcmFtZS5vcGNvZGUgPSAoaSA9PT0gMSkgPyBmcmFtZS5vcGNvZGUgOiAweDAwO1xuICAgICAgICBcbiAgICAgICAgLy8gZmluIHNldCBvbiBsYXN0IGZyYW1lIG9ubHlcbiAgICAgICAgY3VycmVudEZyYW1lLmZpbiA9IChpID09PSBudW1GcmFnbWVudHMpO1xuICAgICAgICBcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGxpa2VseSB0byBiZSBzaG9ydGVyIG9uIHRoZSBsYXN0IGZyYWdtZW50XG4gICAgICAgIHZhciBjdXJyZW50TGVuZ3RoID0gKGkgPT09IG51bUZyYWdtZW50cykgPyBsZW5ndGggLSAodGhyZXNob2xkICogKGktMSkpIDogdGhyZXNob2xkO1xuICAgICAgICB2YXIgc2xpY2VTdGFydCA9IHRocmVzaG9sZCAqIChpLTEpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2xpY2UgdGhlIHJpZ2h0IHBvcnRpb24gb2YgdGhlIG9yaWdpbmFsIHBheWxvYWRcbiAgICAgICAgY3VycmVudEZyYW1lLmJpbmFyeVBheWxvYWQgPSBmcmFtZS5iaW5hcnlQYXlsb2FkLnNsaWNlKHNsaWNlU3RhcnQsIHNsaWNlU3RhcnQgKyBjdXJyZW50TGVuZ3RoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2VuZEZyYW1lKGN1cnJlbnRGcmFtZSwgc2VudENhbGxiYWNrKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kQ2xvc2VGcmFtZSA9IGZ1bmN0aW9uKHJlYXNvbkNvZGUsIGRlc2NyaXB0aW9uLCBjYikge1xuICAgIGlmICh0eXBlb2YocmVhc29uQ29kZSkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlYXNvbkNvZGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uLkNMT1NFX1JFQVNPTl9OT1JNQUw7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuX2RlYnVnKCdzZW5kQ2xvc2VGcmFtZSBzdGF0ZTogJXMsIHJlYXNvbkNvZGU6ICVkLCBkZXNjcmlwdGlvbjogJXMnLCB0aGlzLnN0YXRlLCByZWFzb25Db2RlLCBkZXNjcmlwdGlvbik7XG4gICAgXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX09QRU4gJiYgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfUEVFUl9SRVFVRVNURURfQ0xPU0UpIHsgcmV0dXJuOyB9XG4gICAgXG4gICAgdmFyIGZyYW1lID0gbmV3IFdlYlNvY2tldEZyYW1lKHRoaXMubWFza0J5dGVzLCB0aGlzLmZyYW1lSGVhZGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgZnJhbWUuZmluID0gdHJ1ZTtcbiAgICBmcmFtZS5vcGNvZGUgPSAweDA4OyAvLyBXZWJTb2NrZXRPcGNvZGUuQ09OTkVDVElPTl9DTE9TRVxuICAgIGZyYW1lLmNsb3NlU3RhdHVzID0gcmVhc29uQ29kZTtcbiAgICBpZiAodHlwZW9mKGRlc2NyaXB0aW9uKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZnJhbWUuYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckZyb21TdHJpbmcoZGVzY3JpcHRpb24sICd1dGY4Jyk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2VuZEZyYW1lKGZyYW1lLCBjYik7XG4gICAgdGhpcy5zb2NrZXQuZW5kKCk7XG59O1xuXG5XZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kRnJhbWUgPSBmdW5jdGlvbihmcmFtZSwgY2IpIHtcbiAgICB0aGlzLl9kZWJ1Zygnc2VuZEZyYW1lJyk7XG4gICAgZnJhbWUubWFzayA9IHRoaXMubWFza091dGdvaW5nUGFja2V0cztcbiAgICB2YXIgZmx1c2hlZCA9IHRoaXMuc29ja2V0LndyaXRlKGZyYW1lLnRvQnVmZmVyKCksIGNiKTtcbiAgICB0aGlzLm91dHB1dEJ1ZmZlckZ1bGwgPSAhZmx1c2hlZDtcbiAgICByZXR1cm4gZmx1c2hlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0Q29ubmVjdGlvbjtcblxuXG5cbmZ1bmN0aW9uIGluc3RydW1lbnRTb2NrZXRGb3JEZWJ1Z2dpbmcoY29ubmVjdGlvbiwgc29ja2V0KSB7XG4gICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG4gICAgaWYgKCFjb25uZWN0aW9uLl9kZWJ1Zy5lbmFibGVkKSB7IHJldHVybjsgfVxuICAgIFxuICAgIHZhciBvcmlnaW5hbFNvY2tldEVtaXQgPSBzb2NrZXQuZW1pdDtcbiAgICBzb2NrZXQuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbm5lY3Rpb24uX2RlYnVnKCd8fHwgU29ja2V0IEV2ZW50ICBcXCclc1xcJycsIGV2ZW50KTtcbiAgICAgICAgb3JpZ2luYWxTb2NrZXRFbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBcbiAgICBmb3IgKHZhciBrZXkgaW4gc29ja2V0KSB7XG4gICAgICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2Yoc29ja2V0W2tleV0pKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChbJ2VtaXQnXS5pbmRleE9mKGtleSkgIT09IC0xKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHNvY2tldFtrZXldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ29uJykge1xuICAgICAgICAgICAgICAgIHNvY2tldFtrZXldID0gZnVuY3Rpb24gcHJveHlNZXRob2RfX0V2ZW50RW1pdHRlcl9fT24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uX2RlYnVnKCd8fHwgU29ja2V0IG1ldGhvZCBjYWxsZWQ6ICAlcyAoJXMpJywga2V5LCBhcmd1bWVudHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2tldFtrZXldID0gZnVuY3Rpb24gcHJveHlNZXRob2QoKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5fZGVidWcoJ3x8fCBTb2NrZXQgbWV0aG9kIGNhbGxlZDogICVzJywga2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKGtleSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketConnection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketFrame.js":
/*!******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketFrame.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar bufferUtil = __webpack_require__(/*! bufferutil */ \"(ssr)/./node_modules/bufferutil/index.js\");\nvar bufferAllocUnsafe = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\n\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\n\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n\n            this.fin     = Boolean(firstByte  & 0x80);\n            this.rsv1    = Boolean(firstByte  & 0x40);\n            this.rsv2    = Boolean(firstByte  & 0x20);\n            this.rsv3    = Boolean(firstByte  & 0x10);\n            this.mask    = Boolean(secondByte & 0x80);\n\n            this.opcode  = firstByte  & 0x0F;\n            this.length = secondByte & 0x7F;\n\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = 'Illegal control frame longer than 125 bytes.';\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = 'Control frames must not be fragmented.';\n                    return true;\n                }\n            }\n\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            }\n            else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            }\n            else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n              this.frameHeader.readUInt32BE(2),\n              this.frameHeader.readUInt32BE(2+4)\n            ];\n\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = 'Unsupported 64-bit length frame received';\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        }\n        else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = 'Frame size of ' + this.length.toString(10) +\n                              ' bytes exceeds maximum accepted frame size';\n            return true;\n        }\n\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n                // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n\n            if (this.opcode === 0x08) { // WebSocketOpcode.CONNECTION_CLOSE\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n\n    firstByte |= (this.opcode & 0x0F);\n\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    }\n    else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    }\n    else {\n        this.length = 0;\n    }\n\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= (this.length & 0x7F);\n    }\n    else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n\n    outputPos = 2;\n\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n\n    if (this.mask) {\n        maskKey = nullMask ? 0 : ((Math.random() * 0xFFFFFFFF) >>> 0);\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n\n        if (data) {\n          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    }\n    else if (data) {\n        data.copy(output, outputPos);\n    }\n\n    return output;\n};\n\nWebSocketFrame.prototype.toString = function() {\n    return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;\n};\n\n\nmodule.exports = WebSocketFrame;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRGcmFtZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsNERBQVk7QUFDckMsd0JBQXdCLHFHQUFvQzs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicHJvZGlnaWVzLWN5cHJlc3MvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRGcmFtZS5qcz8wNzk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDb3B5cmlnaHQgMjAxMC0yMDE1IEJyaWFuIE1jS2VsdmV5LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG52YXIgYnVmZmVyQWxsb2NVbnNhZmUgPSByZXF1aXJlKCcuL3V0aWxzJykuYnVmZmVyQWxsb2NVbnNhZmU7XG5cbmNvbnN0IERFQ09ERV9IRUFERVIgPSAxO1xuY29uc3QgV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSCA9IDI7XG5jb25zdCBXQUlUSU5HX0ZPUl82NF9CSVRfTEVOR1RIID0gMztcbmNvbnN0IFdBSVRJTkdfRk9SX01BU0tfS0VZID0gNDtcbmNvbnN0IFdBSVRJTkdfRk9SX1BBWUxPQUQgPSA1O1xuY29uc3QgQ09NUExFVEUgPSA2O1xuXG4vLyBXZWJTb2NrZXRDb25uZWN0aW9uIHdpbGwgcGFzcyBzaGFyZWQgYnVmZmVyIG9iamVjdHMgZm9yIG1hc2tCeXRlcyBhbmRcbi8vIGZyYW1lSGVhZGVyIGludG8gdGhlIGNvbnN0cnVjdG9yIHRvIGF2b2lkIHRvbnMgb2Ygc21hbGwgbWVtb3J5IGFsbG9jYXRpb25zXG4vLyBmb3IgZWFjaCBmcmFtZSB3ZSBoYXZlIHRvIHBhcnNlLiAgVGhpcyBpcyBvbmx5IHVzZWQgZm9yIHBhcnNpbmcgZnJhbWVzXG4vLyB3ZSByZWNlaXZlIG9mZiB0aGUgd2lyZS5cbmZ1bmN0aW9uIFdlYlNvY2tldEZyYW1lKG1hc2tCeXRlcywgZnJhbWVIZWFkZXIsIGNvbmZpZykge1xuICAgIHRoaXMubWFza0J5dGVzID0gbWFza0J5dGVzO1xuICAgIHRoaXMuZnJhbWVIZWFkZXIgPSBmcmFtZUhlYWRlcjtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm1heFJlY2VpdmVkRnJhbWVTaXplID0gY29uZmlnLm1heFJlY2VpdmVkRnJhbWVTaXplO1xuICAgIHRoaXMucHJvdG9jb2xFcnJvciA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVUb29MYXJnZSA9IGZhbHNlO1xuICAgIHRoaXMuaW52YWxpZENsb3NlRnJhbWVMZW5ndGggPSBmYWxzZTtcbiAgICB0aGlzLnBhcnNlU3RhdGUgPSBERUNPREVfSEVBREVSO1xuICAgIHRoaXMuY2xvc2VTdGF0dXMgPSAtMTtcbn1cblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLmFkZERhdGEgPSBmdW5jdGlvbihidWZmZXJMaXN0KSB7XG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gREVDT0RFX0hFQURFUikge1xuICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLmZyYW1lSGVhZGVyLCAwLCAwLCAyKTtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSgyKTtcbiAgICAgICAgICAgIHZhciBmaXJzdEJ5dGUgPSB0aGlzLmZyYW1lSGVhZGVyWzBdO1xuICAgICAgICAgICAgdmFyIHNlY29uZEJ5dGUgPSB0aGlzLmZyYW1lSGVhZGVyWzFdO1xuXG4gICAgICAgICAgICB0aGlzLmZpbiAgICAgPSBCb29sZWFuKGZpcnN0Qnl0ZSAgJiAweDgwKTtcbiAgICAgICAgICAgIHRoaXMucnN2MSAgICA9IEJvb2xlYW4oZmlyc3RCeXRlICAmIDB4NDApO1xuICAgICAgICAgICAgdGhpcy5yc3YyICAgID0gQm9vbGVhbihmaXJzdEJ5dGUgICYgMHgyMCk7XG4gICAgICAgICAgICB0aGlzLnJzdjMgICAgPSBCb29sZWFuKGZpcnN0Qnl0ZSAgJiAweDEwKTtcbiAgICAgICAgICAgIHRoaXMubWFzayAgICA9IEJvb2xlYW4oc2Vjb25kQnl0ZSAmIDB4ODApO1xuXG4gICAgICAgICAgICB0aGlzLm9wY29kZSAgPSBmaXJzdEJ5dGUgICYgMHgwRjtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gc2Vjb25kQnl0ZSAmIDB4N0Y7XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2wgZnJhbWUgc2FuaXR5IGNoZWNrXG4gICAgICAgICAgICBpZiAodGhpcy5vcGNvZGUgPj0gMHgwOCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEyNSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnSWxsZWdhbCBjb250cm9sIGZyYW1lIGxvbmdlciB0aGFuIDEyNSBieXRlcy4nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnQ29udHJvbCBmcmFtZXMgbXVzdCBub3QgYmUgZnJhZ21lbnRlZC4nO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAxMjcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl82NF9CSVRfTEVOR1RIO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVN0YXRlID0gV0FJVElOR19GT1JfTUFTS19LRVk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gV0FJVElOR19GT1JfMTZfQklUX0xFTkdUSCkge1xuICAgICAgICBpZiAoYnVmZmVyTGlzdC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLmZyYW1lSGVhZGVyLCAyLCAwLCAyKTtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSgyKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5mcmFtZUhlYWRlci5yZWFkVUludDE2QkUoMik7XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9NQVNLX0tFWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IFdBSVRJTkdfRk9SXzY0X0JJVF9MRU5HVEgpIHtcbiAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IDgpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxpc3Quam9pbkludG8odGhpcy5mcmFtZUhlYWRlciwgMiwgMCwgOCk7XG4gICAgICAgICAgICBidWZmZXJMaXN0LmFkdmFuY2UoOCk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoUGFpciA9IFtcbiAgICAgICAgICAgICAgdGhpcy5mcmFtZUhlYWRlci5yZWFkVUludDMyQkUoMiksXG4gICAgICAgICAgICAgIHRoaXMuZnJhbWVIZWFkZXIucmVhZFVJbnQzMkJFKDIrNClcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGhQYWlyWzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BSZWFzb24gPSAnVW5zdXBwb3J0ZWQgNjQtYml0IGxlbmd0aCBmcmFtZSByZWNlaXZlZCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aFBhaXJbMV07XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9NQVNLX0tFWTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcnNlU3RhdGUgPT09IFdBSVRJTkdfRk9SX01BU0tfS0VZKSB7XG4gICAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJMaXN0Lmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGlzdC5qb2luSW50byh0aGlzLm1hc2tCeXRlcywgMCwgMCwgNCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKDQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IFdBSVRJTkdfRk9SX1BBWUxPQUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlU3RhdGUgPSBXQUlUSU5HX0ZPUl9QQVlMT0FEO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyc2VTdGF0ZSA9PT0gV0FJVElOR19GT1JfUEFZTE9BRCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiB0aGlzLm1heFJlY2VpdmVkRnJhbWVTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmZyYW1lVG9vTGFyZ2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcm9wUmVhc29uID0gJ0ZyYW1lIHNpemUgb2YgJyArIHRoaXMubGVuZ3RoLnRvU3RyaW5nKDEwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzIGV4Y2VlZHMgbWF4aW11bSBhY2NlcHRlZCBmcmFtZSBzaXplJztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQgPSBidWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQgPSBidWZmZXJMaXN0LnRha2UodGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgYnVmZmVyTGlzdC5hZHZhbmNlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgICAgICAgICBidWZmZXJVdGlsLnVubWFzayh0aGlzLmJpbmFyeVBheWxvYWQsIHRoaXMubWFza0J5dGVzKTtcbiAgICAgICAgICAgICAgICAvLyB4b3IodGhpcy5iaW5hcnlQYXlsb2FkLCB0aGlzLm1hc2tCeXRlcywgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wY29kZSA9PT0gMHgwOCkgeyAvLyBXZWJTb2NrZXRPcGNvZGUuQ09OTkVDVElPTl9DTE9TRVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGxlbmd0aCBmb3IgYSBjbG9zZSBmcmFtZS4gIE11c3QgYmUgemVybyBvciBhdCBsZWFzdCB0d28uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZCA9IGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRDbG9zZUZyYW1lTGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZVN0YXR1cyA9IHRoaXMuYmluYXJ5UGF5bG9hZC5yZWFkVUludDE2QkUoMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluYXJ5UGF5bG9hZCA9IHRoaXMuYmluYXJ5UGF5bG9hZC5zbGljZSgyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRocm93QXdheVBheWxvYWQgPSBmdW5jdGlvbihidWZmZXJMaXN0KSB7XG4gICAgaWYgKGJ1ZmZlckxpc3QubGVuZ3RoID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlckxpc3QuYWR2YW5jZSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMucGFyc2VTdGF0ZSA9IENPTVBMRVRFO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24obnVsbE1hc2spIHtcbiAgICB2YXIgbWFza0tleTtcbiAgICB2YXIgaGVhZGVyTGVuZ3RoID0gMjtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgb3V0cHV0UG9zO1xuICAgIHZhciBmaXJzdEJ5dGUgPSAweDAwO1xuICAgIHZhciBzZWNvbmRCeXRlID0gMHgwMDtcblxuICAgIGlmICh0aGlzLmZpbikge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHg4MDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2MSkge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHg0MDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2Mikge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHgyMDtcbiAgICB9XG4gICAgaWYgKHRoaXMucnN2Mykge1xuICAgICAgICBmaXJzdEJ5dGUgfD0gMHgxMDtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICBzZWNvbmRCeXRlIHw9IDB4ODA7XG4gICAgfVxuXG4gICAgZmlyc3RCeXRlIHw9ICh0aGlzLm9wY29kZSAmIDB4MEYpO1xuXG4gICAgLy8gdGhlIGNsb3NlIGZyYW1lIGlzIGEgc3BlY2lhbCBjYXNlIGJlY2F1c2UgdGhlIGNsb3NlIHJlYXNvbiBpc1xuICAgIC8vIHByZXBlbmRlZCB0byB0aGUgcGF5bG9hZCBkYXRhLlxuICAgIGlmICh0aGlzLm9wY29kZSA9PT0gMHgwOCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVBheWxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IHRoaXMuYmluYXJ5UGF5bG9hZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGJ1ZmZlckFsbG9jVW5zYWZlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZGF0YS53cml0ZVVJbnQxNkJFKHRoaXMuY2xvc2VTdGF0dXMsIDApO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVBheWxvYWQuY29weShkYXRhLCAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmJpbmFyeVBheWxvYWQpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMuYmluYXJ5UGF5bG9hZDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPD0gMTI1KSB7XG4gICAgICAgIC8vIGVuY29kZSB0aGUgbGVuZ3RoIGRpcmVjdGx5IGludG8gdGhlIHR3by1ieXRlIGZyYW1lIGhlYWRlclxuICAgICAgICBzZWNvbmRCeXRlIHw9ICh0aGlzLmxlbmd0aCAmIDB4N0YpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDEyNSAmJiB0aGlzLmxlbmd0aCA8PSAweEZGRkYpIHtcbiAgICAgICAgLy8gVXNlIDE2LWJpdCBsZW5ndGhcbiAgICAgICAgc2Vjb25kQnl0ZSB8PSAxMjY7XG4gICAgICAgIGhlYWRlckxlbmd0aCArPSAyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDB4RkZGRikge1xuICAgICAgICAvLyBVc2UgNjQtYml0IGxlbmd0aFxuICAgICAgICBzZWNvbmRCeXRlIHw9IDEyNztcbiAgICAgICAgaGVhZGVyTGVuZ3RoICs9IDg7XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dCA9IGJ1ZmZlckFsbG9jVW5zYWZlKHRoaXMubGVuZ3RoICsgaGVhZGVyTGVuZ3RoICsgKHRoaXMubWFzayA/IDQgOiAwKSk7XG5cbiAgICAvLyB3cml0ZSB0aGUgZnJhbWUgaGVhZGVyXG4gICAgb3V0cHV0WzBdID0gZmlyc3RCeXRlO1xuICAgIG91dHB1dFsxXSA9IHNlY29uZEJ5dGU7XG5cbiAgICBvdXRwdXRQb3MgPSAyO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMTI1ICYmIHRoaXMubGVuZ3RoIDw9IDB4RkZGRikge1xuICAgICAgICAvLyB3cml0ZSAxNi1iaXQgbGVuZ3RoXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQxNkJFKHRoaXMubGVuZ3RoLCBvdXRwdXRQb3MpO1xuICAgICAgICBvdXRwdXRQb3MgKz0gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPiAweEZGRkYpIHtcbiAgICAgICAgLy8gd3JpdGUgNjQtYml0IGxlbmd0aFxuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRSgweDAwMDAwMDAwLCBvdXRwdXRQb3MpO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRSh0aGlzLmxlbmd0aCwgb3V0cHV0UG9zICsgNCk7XG4gICAgICAgIG91dHB1dFBvcyArPSA4O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgbWFza0tleSA9IG51bGxNYXNrID8gMCA6ICgoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpID4+PiAwKTtcbiAgICAgICAgdGhpcy5tYXNrQnl0ZXMud3JpdGVVSW50MzJCRShtYXNrS2V5LCAwKTtcblxuICAgICAgICAvLyB3cml0ZSB0aGUgbWFzayBrZXlcbiAgICAgICAgdGhpcy5tYXNrQnl0ZXMuY29weShvdXRwdXQsIG91dHB1dFBvcyk7XG4gICAgICAgIG91dHB1dFBvcyArPSA0O1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgYnVmZmVyVXRpbC5tYXNrKGRhdGEsIHRoaXMubWFza0J5dGVzLCBvdXRwdXQsIG91dHB1dFBvcywgdGhpcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5jb3B5KG91dHB1dCwgb3V0cHV0UG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuV2ViU29ja2V0RnJhbWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdPcGNvZGU6ICcgKyB0aGlzLm9wY29kZSArICcsIGZpbjogJyArIHRoaXMuZmluICsgJywgbGVuZ3RoOiAnICsgdGhpcy5sZW5ndGggKyAnLCBoYXNQYXlsb2FkOiAnICsgQm9vbGVhbih0aGlzLmJpbmFyeVBheWxvYWQpICsgJywgbWFza2VkOiAnICsgdGhpcy5tYXNrO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldEZyYW1lO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketFrame.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"(ssr)/./node_modules/websocket/lib/WebSocketConnection.js\");\n\nvar headerValueSplitRegExp = /,\\s*/;\nvar headerParamSplitRegExp = /;\\s*/;\nvar headerSanitizeRegExp = /[\\r\\n]/g;\nvar xForwardedForSeparatorRegExp = /,\\s*/;\nvar separators = [\n    '(', ')', '<', '>', '@',\n    ',', ';', ':', '\\\\', '\\\"',\n    '/', '[', ']', '?', '=',\n    '{', '}', ' ', String.fromCharCode(9)\n];\nvar controlChars = [String.fromCharCode(127) /* DEL */];\nfor (var i=0; i < 31; i ++) {\n    /* US-ASCII Control Characters */\n    controlChars.push(String.fromCharCode(i));\n}\n\nvar cookieNameValidateRegEx = /([\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2f\\x3a-\\x3f\\x40\\x5b-\\x5e\\x7b\\x7d\\x7f])/;\nvar cookieValueValidateRegEx = /[^\\x21\\x23-\\x2b\\x2d-\\x3a\\x3c-\\x5b\\x5d-\\x7e]/;\nvar cookieValueDQuoteValidateRegEx = /^\"[^\"]*\"$/;\nvar controlCharsAndSemicolonRegEx = /[\\x00-\\x20\\x3b]/g;\n\nvar cookieSeparatorRegEx = /[;,] */;\n\nvar httpStatusDescriptions = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    200: 'OK',\n    201: 'Created',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    406: 'Not Acceptable',\n    407: 'Proxy Authorization Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Request Entity Too Long',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Requested Range Not Satisfiable',\n    417: 'Expectation Failed',\n    426: 'Upgrade Required',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported'\n};\n\nfunction WebSocketRequest(socket, httpRequest, serverConfig) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.socket = socket;\n    this.httpRequest = httpRequest;\n    this.resource = httpRequest.url;\n    this.remoteAddress = socket.remoteAddress;\n    this.remoteAddresses = [this.remoteAddress];\n    this.serverConfig = serverConfig;\n\n    // Watch for the underlying TCP socket closing before we call accept\n    this._socketIsClosing = false;\n    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);\n    this.socket.on('end', this._socketCloseHandler);\n    this.socket.on('close', this._socketCloseHandler);\n\n    this._resolved = false;\n}\n\nutil.inherits(WebSocketRequest, EventEmitter);\n\nWebSocketRequest.prototype.readHandshake = function() {\n    var self = this;\n    var request = this.httpRequest;\n\n    // Decode URL\n    this.resourceURL = url.parse(this.resource, true);\n\n    this.host = request.headers['host'];\n    if (!this.host) {\n        throw new Error('Client must provide a Host header.');\n    }\n\n    this.key = request.headers['sec-websocket-key'];\n    if (!this.key) {\n        throw new Error('Client must provide a value for Sec-WebSocket-Key.');\n    }\n\n    this.webSocketVersion = parseInt(request.headers['sec-websocket-version'], 10);\n\n    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {\n        throw new Error('Client must provide a value for Sec-WebSocket-Version.');\n    }\n\n    switch (this.webSocketVersion) {\n        case 8:\n        case 13:\n            break;\n        default:\n            var e = new Error('Unsupported websocket client version: ' + this.webSocketVersion +\n                              'Only versions 8 and 13 are supported.');\n            e.httpCode = 426;\n            e.headers = {\n                'Sec-WebSocket-Version': '13'\n            };\n            throw e;\n    }\n\n    if (this.webSocketVersion === 13) {\n        this.origin = request.headers['origin'];\n    }\n    else if (this.webSocketVersion === 8) {\n        this.origin = request.headers['sec-websocket-origin'];\n    }\n\n    // Protocol is optional.\n    var protocolString = request.headers['sec-websocket-protocol'];\n    this.protocolFullCaseMap = {};\n    this.requestedProtocols = [];\n    if (protocolString) {\n        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);\n        requestedProtocolsFullCase.forEach(function(protocol) {\n            var lcProtocol = protocol.toLocaleLowerCase();\n            self.requestedProtocols.push(lcProtocol);\n            self.protocolFullCaseMap[lcProtocol] = protocol;\n        });\n    }\n\n    if (!this.serverConfig.ignoreXForwardedFor &&\n        request.headers['x-forwarded-for']) {\n        var immediatePeerIP = this.remoteAddress;\n        this.remoteAddresses = request.headers['x-forwarded-for']\n            .split(xForwardedForSeparatorRegExp);\n        this.remoteAddresses.push(immediatePeerIP);\n        this.remoteAddress = this.remoteAddresses[0];\n    }\n\n    // Extensions are optional.\n    if (this.serverConfig.parseExtensions) {\n        var extensionsString = request.headers['sec-websocket-extensions'];\n        this.requestedExtensions = this.parseExtensions(extensionsString);\n    } else {\n        this.requestedExtensions = [];\n    }\n\n    // Cookies are optional\n    if (this.serverConfig.parseCookies) {\n        var cookieString = request.headers['cookie'];\n        this.cookies = this.parseCookies(cookieString);\n    } else {\n        this.cookies = [];\n    }\n};\n\nWebSocketRequest.prototype.parseExtensions = function(extensionsString) {\n    if (!extensionsString || extensionsString.length === 0) {\n        return [];\n    }\n    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);\n    extensions.forEach(function(extension, index, array) {\n        var params = extension.split(headerParamSplitRegExp);\n        var extensionName = params[0];\n        var extensionParams = params.slice(1);\n        extensionParams.forEach(function(rawParam, index, array) {\n            var arr = rawParam.split('=');\n            var obj = {\n                name: arr[0],\n                value: arr[1]\n            };\n            array.splice(index, 1, obj);\n        });\n        var obj = {\n            name: extensionName,\n            params: extensionParams\n        };\n        array.splice(index, 1, obj);\n    });\n    return extensions;\n};\n\n// This function adapted from node-cookie\n// https://github.com/shtylman/node-cookie\nWebSocketRequest.prototype.parseCookies = function(str) {\n    // Sanity Check\n    if (!str || typeof(str) !== 'string') {\n        return [];\n    }\n\n    var cookies = [];\n    var pairs = str.split(cookieSeparatorRegEx);\n\n    pairs.forEach(function(pair) {\n        var eq_idx = pair.indexOf('=');\n        if (eq_idx === -1) {\n            cookies.push({\n                name: pair,\n                value: null\n            });\n            return;\n        }\n\n        var key = pair.substr(0, eq_idx).trim();\n        var val = pair.substr(++eq_idx, pair.length).trim();\n\n        // quoted values\n        if ('\"' === val[0]) {\n            val = val.slice(1, -1);\n        }\n\n        cookies.push({\n            name: key,\n            value: decodeURIComponent(val)\n        });\n    });\n\n    return cookies;\n};\n\nWebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {\n    this._verifyResolution();\n\n    // TODO: Handle extensions\n\n    var protocolFullCase;\n\n    if (acceptedProtocol) {\n        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];\n        if (typeof(protocolFullCase) === 'undefined') {\n            protocolFullCase = acceptedProtocol;\n        }\n    }\n    else {\n        protocolFullCase = acceptedProtocol;\n    }\n    this.protocolFullCaseMap = null;\n\n    // Create key validation hash\n    var sha1 = crypto.createHash('sha1');\n    sha1.update(this.key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n    var acceptKey = sha1.digest('base64');\n\n    var response = 'HTTP/1.1 101 Switching Protocols\\r\\n' +\n                   'Upgrade: websocket\\r\\n' +\n                   'Connection: Upgrade\\r\\n' +\n                   'Sec-WebSocket-Accept: ' + acceptKey + '\\r\\n';\n\n    if (protocolFullCase) {\n        // validate protocol\n        for (var i=0; i < protocolFullCase.length; i++) {\n            var charCode = protocolFullCase.charCodeAt(i);\n            var character = protocolFullCase.charAt(i);\n            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {\n                this.reject(500);\n                throw new Error('Illegal character \"' + String.fromCharCode(character) + '\" in subprotocol.');\n            }\n        }\n        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {\n            this.reject(500);\n            throw new Error('Specified protocol was not requested by the client.');\n        }\n\n        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, '');\n        response += 'Sec-WebSocket-Protocol: ' + protocolFullCase + '\\r\\n';\n    }\n    this.requestedProtocols = null;\n\n    if (allowedOrigin) {\n        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, '');\n        if (this.webSocketVersion === 13) {\n            response += 'Origin: ' + allowedOrigin + '\\r\\n';\n        }\n        else if (this.webSocketVersion === 8) {\n            response += 'Sec-WebSocket-Origin: ' + allowedOrigin + '\\r\\n';\n        }\n    }\n\n    if (cookies) {\n        if (!Array.isArray(cookies)) {\n            this.reject(500);\n            throw new Error('Value supplied for \"cookies\" argument must be an array.');\n        }\n        var seenCookies = {};\n        cookies.forEach(function(cookie) {\n            if (!cookie.name || !cookie.value) {\n                this.reject(500);\n                throw new Error('Each cookie to set must at least provide a \"name\" and \"value\"');\n            }\n\n            // Make sure there are no \\r\\n sequences inserted\n            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, '');\n            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, '');\n\n            if (seenCookies[cookie.name]) {\n                this.reject(500);\n                throw new Error('You may not specify the same cookie name twice.');\n            }\n            seenCookies[cookie.name] = true;\n\n            // token (RFC 2616, Section 2.2)\n            var invalidChar = cookie.name.match(cookieNameValidateRegEx);\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie name');\n            }\n\n            // RFC 6265, Section 4.1.1\n            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {\n                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);\n            } else {\n                invalidChar = cookie.value.match(cookieValueValidateRegEx);\n            }\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie value');\n            }\n\n            var cookieParts = [cookie.name + '=' + cookie.value];\n\n            // RFC 6265, Section 4.1.1\n            // 'Path=' path-value | <any CHAR except CTLs or ';'>\n            if(cookie.path){\n                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie path');\n                }\n                cookieParts.push('Path=' + cookie.path);\n            }\n\n            // RFC 6265, Section 4.1.2.3\n            // 'Domain=' subdomain\n            if (cookie.domain) {\n                if (typeof(cookie.domain) !== 'string') {\n                    this.reject(500);\n                    throw new Error('Domain must be specified and must be a string.');\n                }\n                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie domain');\n                }\n                cookieParts.push('Domain=' + cookie.domain.toLowerCase());\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch\n            if (cookie.expires) {\n                if (!(cookie.expires instanceof Date)){\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"expires\" must be a vaild date object');\n                }\n                cookieParts.push('Expires=' + cookie.expires.toGMTString());\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Max-Age=' non-zero-digit *DIGIT\n            if (cookie.maxage) {\n                var maxage = cookie.maxage;\n                if (typeof(maxage) === 'string') {\n                    maxage = parseInt(maxage, 10);\n                }\n                if (isNaN(maxage) || maxage <= 0 ) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"maxage\" must be a non-zero number');\n                }\n                maxage = Math.round(maxage);\n                cookieParts.push('Max-Age=' + maxage.toString(10));\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Secure;'\n            if (cookie.secure) {\n                if (typeof(cookie.secure) !== 'boolean') {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"secure\" must be of type boolean');\n                }\n                cookieParts.push('Secure');\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'HttpOnly;'\n            if (cookie.httponly) {\n                if (typeof(cookie.httponly) !== 'boolean') {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"httponly\" must be of type boolean');\n                }\n                cookieParts.push('HttpOnly');\n            }\n\n            response += ('Set-Cookie: ' + cookieParts.join(';') + '\\r\\n');\n        }.bind(this));\n    }\n\n    // TODO: handle negotiated extensions\n    // if (negotiatedExtensions) {\n    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\\r\\n';\n    // }\n\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit('requestResolved', this);\n\n    response += '\\r\\n';\n\n    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);\n    connection.webSocketVersion = this.webSocketVersion;\n    connection.remoteAddress = this.remoteAddress;\n    connection.remoteAddresses = this.remoteAddresses;\n\n    var self = this;\n\n    if (this._socketIsClosing) {\n        // Handle case when the client hangs up before we get a chance to\n        // accept the connection and send our side of the opening handshake.\n        cleanupFailedConnection(connection);\n    }\n    else {\n        this.socket.write(response, 'ascii', function(error) {\n            if (error) {\n                cleanupFailedConnection(connection);\n                return;\n            }\n\n            self._removeSocketCloseListeners();\n            connection._addSocketEventListeners();\n        });\n    }\n\n    this.emit('requestAccepted', connection);\n    return connection;\n};\n\nWebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this._verifyResolution();\n\n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit('requestResolved', this);\n\n    if (typeof(status) !== 'number') {\n        status = 403;\n    }\n    var response = 'HTTP/1.1 ' + status + ' ' + httpStatusDescriptions[status] + '\\r\\n' +\n                   'Connection: close\\r\\n';\n    if (reason) {\n        reason = reason.replace(headerSanitizeRegExp, '');\n        response += 'X-WebSocket-Reject-Reason: ' + reason + '\\r\\n';\n    }\n\n    if (extraHeaders) {\n        for (var key in extraHeaders) {\n            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, '');\n            var sanitizedKey = key.replace(headerSanitizeRegExp, '');\n            response += (sanitizedKey + ': ' + sanitizedValue + '\\r\\n');\n        }\n    }\n\n    response += '\\r\\n';\n    this.socket.end(response, 'ascii');\n\n    this.emit('requestRejected', this);\n};\n\nWebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {\n    this._socketIsClosing = true;\n    this._removeSocketCloseListeners();\n};\n\nWebSocketRequest.prototype._removeSocketCloseListeners = function() {\n    this.socket.removeListener('end', this._socketCloseHandler);\n    this.socket.removeListener('close', this._socketCloseHandler);\n};\n\nWebSocketRequest.prototype._verifyResolution = function() {\n    if (this._resolved) {\n        throw new Error('WebSocketRequest may only be accepted or rejected one time.');\n    }\n};\n\nfunction cleanupFailedConnection(connection) {\n    // Since we have to return a connection object even if the socket is\n    // already dead in order not to break the API, we schedule a 'close'\n    // event on the connection object to occur immediately.\n    process.nextTick(function() {\n        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006\n        // Third param: Skip sending the close frame to a dead socket\n        connection.drop(1006, 'TCP connection lost before handshake completed.', true);\n    });\n}\n\nmodule.exports = WebSocketRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QixtQkFBbUIsMERBQThCO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLHdGQUF1Qjs7QUFFekQ7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxNQUFNLEtBQUs7QUFDWDtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkRBQTZEO0FBQzdELFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJlcXVlc3QuanM/ZDNmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBXZWJTb2NrZXRDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9XZWJTb2NrZXRDb25uZWN0aW9uJyk7XG5cbnZhciBoZWFkZXJWYWx1ZVNwbGl0UmVnRXhwID0gLyxcXHMqLztcbnZhciBoZWFkZXJQYXJhbVNwbGl0UmVnRXhwID0gLztcXHMqLztcbnZhciBoZWFkZXJTYW5pdGl6ZVJlZ0V4cCA9IC9bXFxyXFxuXS9nO1xudmFyIHhGb3J3YXJkZWRGb3JTZXBhcmF0b3JSZWdFeHAgPSAvLFxccyovO1xudmFyIHNlcGFyYXRvcnMgPSBbXG4gICAgJygnLCAnKScsICc8JywgJz4nLCAnQCcsXG4gICAgJywnLCAnOycsICc6JywgJ1xcXFwnLCAnXFxcIicsXG4gICAgJy8nLCAnWycsICddJywgJz8nLCAnPScsXG4gICAgJ3snLCAnfScsICcgJywgU3RyaW5nLmZyb21DaGFyQ29kZSg5KVxuXTtcbnZhciBjb250cm9sQ2hhcnMgPSBbU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpIC8qIERFTCAqL107XG5mb3IgKHZhciBpPTA7IGkgPCAzMTsgaSArKykge1xuICAgIC8qIFVTLUFTQ0lJIENvbnRyb2wgQ2hhcmFjdGVycyAqL1xuICAgIGNvbnRyb2xDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xufVxuXG52YXIgY29va2llTmFtZVZhbGlkYXRlUmVnRXggPSAvKFtcXHgwMC1cXHgyMFxceDIyXFx4MjhcXHgyOVxceDJjXFx4MmZcXHgzYS1cXHgzZlxceDQwXFx4NWItXFx4NWVcXHg3YlxceDdkXFx4N2ZdKS87XG52YXIgY29va2llVmFsdWVWYWxpZGF0ZVJlZ0V4ID0gL1teXFx4MjFcXHgyMy1cXHgyYlxceDJkLVxceDNhXFx4M2MtXFx4NWJcXHg1ZC1cXHg3ZV0vO1xudmFyIGNvb2tpZVZhbHVlRFF1b3RlVmFsaWRhdGVSZWdFeCA9IC9eXCJbXlwiXSpcIiQvO1xudmFyIGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4ID0gL1tcXHgwMC1cXHgyMFxceDNiXS9nO1xuXG52YXIgY29va2llU2VwYXJhdG9yUmVnRXggPSAvWzssXSAqLztcblxudmFyIGh0dHBTdGF0dXNEZXNjcmlwdGlvbnMgPSB7XG4gICAgMTAwOiAnQ29udGludWUnLFxuICAgIDEwMTogJ1N3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgIDIwMDogJ09LJyxcbiAgICAyMDE6ICdDcmVhdGVkJyxcbiAgICAyMDM6ICdOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvbicsXG4gICAgMjA0OiAnTm8gQ29udGVudCcsXG4gICAgMjA1OiAnUmVzZXQgQ29udGVudCcsXG4gICAgMjA2OiAnUGFydGlhbCBDb250ZW50JyxcbiAgICAzMDA6ICdNdWx0aXBsZSBDaG9pY2VzJyxcbiAgICAzMDE6ICdNb3ZlZCBQZXJtYW5lbnRseScsXG4gICAgMzAyOiAnRm91bmQnLFxuICAgIDMwMzogJ1NlZSBPdGhlcicsXG4gICAgMzA0OiAnTm90IE1vZGlmaWVkJyxcbiAgICAzMDU6ICdVc2UgUHJveHknLFxuICAgIDMwNzogJ1RlbXBvcmFyeSBSZWRpcmVjdCcsXG4gICAgNDAwOiAnQmFkIFJlcXVlc3QnLFxuICAgIDQwMTogJ1VuYXV0aG9yaXplZCcsXG4gICAgNDAyOiAnUGF5bWVudCBSZXF1aXJlZCcsXG4gICAgNDAzOiAnRm9yYmlkZGVuJyxcbiAgICA0MDQ6ICdOb3QgRm91bmQnLFxuICAgIDQwNjogJ05vdCBBY2NlcHRhYmxlJyxcbiAgICA0MDc6ICdQcm94eSBBdXRob3JpemF0aW9uIFJlcXVpcmVkJyxcbiAgICA0MDg6ICdSZXF1ZXN0IFRpbWVvdXQnLFxuICAgIDQwOTogJ0NvbmZsaWN0JyxcbiAgICA0MTA6ICdHb25lJyxcbiAgICA0MTE6ICdMZW5ndGggUmVxdWlyZWQnLFxuICAgIDQxMjogJ1ByZWNvbmRpdGlvbiBGYWlsZWQnLFxuICAgIDQxMzogJ1JlcXVlc3QgRW50aXR5IFRvbyBMb25nJyxcbiAgICA0MTQ6ICdSZXF1ZXN0LVVSSSBUb28gTG9uZycsXG4gICAgNDE1OiAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZScsXG4gICAgNDE2OiAnUmVxdWVzdGVkIFJhbmdlIE5vdCBTYXRpc2ZpYWJsZScsXG4gICAgNDE3OiAnRXhwZWN0YXRpb24gRmFpbGVkJyxcbiAgICA0MjY6ICdVcGdyYWRlIFJlcXVpcmVkJyxcbiAgICA1MDA6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuICAgIDUwMTogJ05vdCBJbXBsZW1lbnRlZCcsXG4gICAgNTAyOiAnQmFkIEdhdGV3YXknLFxuICAgIDUwMzogJ1NlcnZpY2UgVW5hdmFpbGFibGUnLFxuICAgIDUwNDogJ0dhdGV3YXkgVGltZW91dCcsXG4gICAgNTA1OiAnSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnXG59O1xuXG5mdW5jdGlvbiBXZWJTb2NrZXRSZXF1ZXN0KHNvY2tldCwgaHR0cFJlcXVlc3QsIHNlcnZlckNvbmZpZykge1xuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBodHRwUmVxdWVzdDtcbiAgICB0aGlzLnJlc291cmNlID0gaHR0cFJlcXVlc3QudXJsO1xuICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgIHRoaXMucmVtb3RlQWRkcmVzc2VzID0gW3RoaXMucmVtb3RlQWRkcmVzc107XG4gICAgdGhpcy5zZXJ2ZXJDb25maWcgPSBzZXJ2ZXJDb25maWc7XG5cbiAgICAvLyBXYXRjaCBmb3IgdGhlIHVuZGVybHlpbmcgVENQIHNvY2tldCBjbG9zaW5nIGJlZm9yZSB3ZSBjYWxsIGFjY2VwdFxuICAgIHRoaXMuX3NvY2tldElzQ2xvc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX3NvY2tldENsb3NlSGFuZGxlciA9IHRoaXMuX2hhbmRsZVNvY2tldENsb3NlQmVmb3JlQWNjZXB0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2VuZCcsIHRoaXMuX3NvY2tldENsb3NlSGFuZGxlcik7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyKTtcblxuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG59XG5cbnV0aWwuaW5oZXJpdHMoV2ViU29ja2V0UmVxdWVzdCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUucmVhZEhhbmRzaGFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVxdWVzdCA9IHRoaXMuaHR0cFJlcXVlc3Q7XG5cbiAgICAvLyBEZWNvZGUgVVJMXG4gICAgdGhpcy5yZXNvdXJjZVVSTCA9IHVybC5wYXJzZSh0aGlzLnJlc291cmNlLCB0cnVlKTtcblxuICAgIHRoaXMuaG9zdCA9IHJlcXVlc3QuaGVhZGVyc1snaG9zdCddO1xuICAgIGlmICghdGhpcy5ob3N0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG11c3QgcHJvdmlkZSBhIEhvc3QgaGVhZGVyLicpO1xuICAgIH1cblxuICAgIHRoaXMua2V5ID0gcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddO1xuICAgIGlmICghdGhpcy5rZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbXVzdCBwcm92aWRlIGEgdmFsdWUgZm9yIFNlYy1XZWJTb2NrZXQtS2V5LicpO1xuICAgIH1cblxuICAgIHRoaXMud2ViU29ja2V0VmVyc2lvbiA9IHBhcnNlSW50KHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ10sIDEwKTtcblxuICAgIGlmICghdGhpcy53ZWJTb2NrZXRWZXJzaW9uIHx8IGlzTmFOKHRoaXMud2ViU29ja2V0VmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbXVzdCBwcm92aWRlIGEgdmFsdWUgZm9yIFNlYy1XZWJTb2NrZXQtVmVyc2lvbi4nKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMud2ViU29ja2V0VmVyc2lvbikge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB3ZWJzb2NrZXQgY2xpZW50IHZlcnNpb246ICcgKyB0aGlzLndlYlNvY2tldFZlcnNpb24gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ09ubHkgdmVyc2lvbnMgOCBhbmQgMTMgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIGUuaHR0cENvZGUgPSA0MjY7XG4gICAgICAgICAgICBlLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6ICcxMydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndlYlNvY2tldFZlcnNpb24gPT09IDEzKSB7XG4gICAgICAgIHRoaXMub3JpZ2luID0gcmVxdWVzdC5oZWFkZXJzWydvcmlnaW4nXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy53ZWJTb2NrZXRWZXJzaW9uID09PSA4KSB7XG4gICAgICAgIHRoaXMub3JpZ2luID0gcmVxdWVzdC5oZWFkZXJzWydzZWMtd2Vic29ja2V0LW9yaWdpbiddO1xuICAgIH1cblxuICAgIC8vIFByb3RvY29sIGlzIG9wdGlvbmFsLlxuICAgIHZhciBwcm90b2NvbFN0cmluZyA9IHJlcXVlc3QuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIHRoaXMucHJvdG9jb2xGdWxsQ2FzZU1hcCA9IHt9O1xuICAgIHRoaXMucmVxdWVzdGVkUHJvdG9jb2xzID0gW107XG4gICAgaWYgKHByb3RvY29sU3RyaW5nKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ZWRQcm90b2NvbHNGdWxsQ2FzZSA9IHByb3RvY29sU3RyaW5nLnNwbGl0KGhlYWRlclZhbHVlU3BsaXRSZWdFeHApO1xuICAgICAgICByZXF1ZXN0ZWRQcm90b2NvbHNGdWxsQ2FzZS5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvY29sKSB7XG4gICAgICAgICAgICB2YXIgbGNQcm90b2NvbCA9IHByb3RvY29sLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBzZWxmLnJlcXVlc3RlZFByb3RvY29scy5wdXNoKGxjUHJvdG9jb2wpO1xuICAgICAgICAgICAgc2VsZi5wcm90b2NvbEZ1bGxDYXNlTWFwW2xjUHJvdG9jb2xdID0gcHJvdG9jb2w7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zZXJ2ZXJDb25maWcuaWdub3JlWEZvcndhcmRlZEZvciAmJlxuICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ3gtZm9yd2FyZGVkLWZvciddKSB7XG4gICAgICAgIHZhciBpbW1lZGlhdGVQZWVySVAgPSB0aGlzLnJlbW90ZUFkZHJlc3M7XG4gICAgICAgIHRoaXMucmVtb3RlQWRkcmVzc2VzID0gcmVxdWVzdC5oZWFkZXJzWyd4LWZvcndhcmRlZC1mb3InXVxuICAgICAgICAgICAgLnNwbGl0KHhGb3J3YXJkZWRGb3JTZXBhcmF0b3JSZWdFeHApO1xuICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3Nlcy5wdXNoKGltbWVkaWF0ZVBlZXJJUCk7XG4gICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHRoaXMucmVtb3RlQWRkcmVzc2VzWzBdO1xuICAgIH1cblxuICAgIC8vIEV4dGVuc2lvbnMgYXJlIG9wdGlvbmFsLlxuICAgIGlmICh0aGlzLnNlcnZlckNvbmZpZy5wYXJzZUV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFyIGV4dGVuc2lvbnNTdHJpbmcgPSByZXF1ZXN0LmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgICAgICB0aGlzLnJlcXVlc3RlZEV4dGVuc2lvbnMgPSB0aGlzLnBhcnNlRXh0ZW5zaW9ucyhleHRlbnNpb25zU3RyaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlcXVlc3RlZEV4dGVuc2lvbnMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBDb29raWVzIGFyZSBvcHRpb25hbFxuICAgIGlmICh0aGlzLnNlcnZlckNvbmZpZy5wYXJzZUNvb2tpZXMpIHtcbiAgICAgICAgdmFyIGNvb2tpZVN0cmluZyA9IHJlcXVlc3QuaGVhZGVyc1snY29va2llJ107XG4gICAgICAgIHRoaXMuY29va2llcyA9IHRoaXMucGFyc2VDb29raWVzKGNvb2tpZVN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb29raWVzID0gW107XG4gICAgfVxufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUucGFyc2VFeHRlbnNpb25zID0gZnVuY3Rpb24oZXh0ZW5zaW9uc1N0cmluZykge1xuICAgIGlmICghZXh0ZW5zaW9uc1N0cmluZyB8fCBleHRlbnNpb25zU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciBleHRlbnNpb25zID0gZXh0ZW5zaW9uc1N0cmluZy50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KGhlYWRlclZhbHVlU3BsaXRSZWdFeHApO1xuICAgIGV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbihleHRlbnNpb24sIGluZGV4LCBhcnJheSkge1xuICAgICAgICB2YXIgcGFyYW1zID0gZXh0ZW5zaW9uLnNwbGl0KGhlYWRlclBhcmFtU3BsaXRSZWdFeHApO1xuICAgICAgICB2YXIgZXh0ZW5zaW9uTmFtZSA9IHBhcmFtc1swXTtcbiAgICAgICAgdmFyIGV4dGVuc2lvblBhcmFtcyA9IHBhcmFtcy5zbGljZSgxKTtcbiAgICAgICAgZXh0ZW5zaW9uUGFyYW1zLmZvckVhY2goZnVuY3Rpb24ocmF3UGFyYW0sIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgdmFyIGFyciA9IHJhd1BhcmFtLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGFyclswXSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogYXJyWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxLCBvYmopO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbk5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IGV4dGVuc2lvblBhcmFtc1xuICAgICAgICB9O1xuICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEsIG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbnM7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGFkYXB0ZWQgZnJvbSBub2RlLWNvb2tpZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NodHlsbWFuL25vZGUtY29va2llXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5wYXJzZUNvb2tpZXMgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAvLyBTYW5pdHkgQ2hlY2tcbiAgICBpZiAoIXN0ciB8fCB0eXBlb2Yoc3RyKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBjb29raWVzID0gW107XG4gICAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KGNvb2tpZVNlcGFyYXRvclJlZ0V4KTtcblxuICAgIHBhaXJzLmZvckVhY2goZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgZXFfaWR4ID0gcGFpci5pbmRleE9mKCc9Jyk7XG4gICAgICAgIGlmIChlcV9pZHggPT09IC0xKSB7XG4gICAgICAgICAgICBjb29raWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhaXIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleSA9IHBhaXIuc3Vic3RyKDAsIGVxX2lkeCkudHJpbSgpO1xuICAgICAgICB2YXIgdmFsID0gcGFpci5zdWJzdHIoKytlcV9pZHgsIHBhaXIubGVuZ3RoKS50cmltKCk7XG5cbiAgICAgICAgLy8gcXVvdGVkIHZhbHVlc1xuICAgICAgICBpZiAoJ1wiJyA9PT0gdmFsWzBdKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29va2llcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVVUklDb21wb25lbnQodmFsKVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb29raWVzO1xufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24oYWNjZXB0ZWRQcm90b2NvbCwgYWxsb3dlZE9yaWdpbiwgY29va2llcykge1xuICAgIHRoaXMuX3ZlcmlmeVJlc29sdXRpb24oKTtcblxuICAgIC8vIFRPRE86IEhhbmRsZSBleHRlbnNpb25zXG5cbiAgICB2YXIgcHJvdG9jb2xGdWxsQ2FzZTtcblxuICAgIGlmIChhY2NlcHRlZFByb3RvY29sKSB7XG4gICAgICAgIHByb3RvY29sRnVsbENhc2UgPSB0aGlzLnByb3RvY29sRnVsbENhc2VNYXBbYWNjZXB0ZWRQcm90b2NvbC50b0xvY2FsZUxvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKHR5cGVvZihwcm90b2NvbEZ1bGxDYXNlKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHByb3RvY29sRnVsbENhc2UgPSBhY2NlcHRlZFByb3RvY29sO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm90b2NvbEZ1bGxDYXNlID0gYWNjZXB0ZWRQcm90b2NvbDtcbiAgICB9XG4gICAgdGhpcy5wcm90b2NvbEZ1bGxDYXNlTWFwID0gbnVsbDtcblxuICAgIC8vIENyZWF0ZSBrZXkgdmFsaWRhdGlvbiBoYXNoXG4gICAgdmFyIHNoYTEgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpO1xuICAgIHNoYTEudXBkYXRlKHRoaXMua2V5ICsgJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScpO1xuICAgIHZhciBhY2NlcHRLZXkgPSBzaGExLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICB2YXIgcmVzcG9uc2UgPSAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHNcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnVXBncmFkZTogd2Vic29ja2V0XFxyXFxuJyArXG4gICAgICAgICAgICAgICAgICAgJ0Nvbm5lY3Rpb246IFVwZ3JhZGVcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICcgKyBhY2NlcHRLZXkgKyAnXFxyXFxuJztcblxuICAgIGlmIChwcm90b2NvbEZ1bGxDYXNlKSB7XG4gICAgICAgIC8vIHZhbGlkYXRlIHByb3RvY29sXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHByb3RvY29sRnVsbENhc2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHByb3RvY29sRnVsbENhc2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSBwcm90b2NvbEZ1bGxDYXNlLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDB4MjEgfHwgY2hhckNvZGUgPiAweDdFIHx8IHNlcGFyYXRvcnMuaW5kZXhPZihjaGFyYWN0ZXIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGNoYXJhY3RlciBcIicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJhY3RlcikgKyAnXCIgaW4gc3VicHJvdG9jb2wuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdGVkUHJvdG9jb2xzLmluZGV4T2YoYWNjZXB0ZWRQcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTcGVjaWZpZWQgcHJvdG9jb2wgd2FzIG5vdCByZXF1ZXN0ZWQgYnkgdGhlIGNsaWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvY29sRnVsbENhc2UgPSBwcm90b2NvbEZ1bGxDYXNlLnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgcmVzcG9uc2UgKz0gJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2w6ICcgKyBwcm90b2NvbEZ1bGxDYXNlICsgJ1xcclxcbic7XG4gICAgfVxuICAgIHRoaXMucmVxdWVzdGVkUHJvdG9jb2xzID0gbnVsbDtcblxuICAgIGlmIChhbGxvd2VkT3JpZ2luKSB7XG4gICAgICAgIGFsbG93ZWRPcmlnaW4gPSBhbGxvd2VkT3JpZ2luLnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgaWYgKHRoaXMud2ViU29ja2V0VmVyc2lvbiA9PT0gMTMpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlICs9ICdPcmlnaW46ICcgKyBhbGxvd2VkT3JpZ2luICsgJ1xcclxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53ZWJTb2NrZXRWZXJzaW9uID09PSA4KSB7XG4gICAgICAgICAgICByZXNwb25zZSArPSAnU2VjLVdlYlNvY2tldC1PcmlnaW46ICcgKyBhbGxvd2VkT3JpZ2luICsgJ1xcclxcbic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29va2llcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29va2llcykpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBcImNvb2tpZXNcIiBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVuQ29va2llcyA9IHt9O1xuICAgICAgICBjb29raWVzLmZvckVhY2goZnVuY3Rpb24oY29va2llKSB7XG4gICAgICAgICAgICBpZiAoIWNvb2tpZS5uYW1lIHx8ICFjb29raWUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWFjaCBjb29raWUgdG8gc2V0IG11c3QgYXQgbGVhc3QgcHJvdmlkZSBhIFwibmFtZVwiIGFuZCBcInZhbHVlXCInKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBcXHJcXG4gc2VxdWVuY2VzIGluc2VydGVkXG4gICAgICAgICAgICBjb29raWUubmFtZSA9IGNvb2tpZS5uYW1lLnJlcGxhY2UoY29udHJvbENoYXJzQW5kU2VtaWNvbG9uUmVnRXgsICcnKTtcbiAgICAgICAgICAgIGNvb2tpZS52YWx1ZSA9IGNvb2tpZS52YWx1ZS5yZXBsYWNlKGNvbnRyb2xDaGFyc0FuZFNlbWljb2xvblJlZ0V4LCAnJyk7XG5cbiAgICAgICAgICAgIGlmIChzZWVuQ29va2llc1tjb29raWUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBub3Qgc3BlY2lmeSB0aGUgc2FtZSBjb29raWUgbmFtZSB0d2ljZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5Db29raWVzW2Nvb2tpZS5uYW1lXSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHRva2VuIChSRkMgMjYxNiwgU2VjdGlvbiAyLjIpXG4gICAgICAgICAgICB2YXIgaW52YWxpZENoYXIgPSBjb29raWUubmFtZS5tYXRjaChjb29raWVOYW1lVmFsaWRhdGVSZWdFeCk7XG4gICAgICAgICAgICBpZiAoaW52YWxpZENoYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgJyArIGludmFsaWRDaGFyWzBdICsgJyBpbiBjb29raWUgbmFtZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSRkMgNjI2NSwgU2VjdGlvbiA0LjEuMVxuICAgICAgICAgICAgLy8gKmNvb2tpZS1vY3RldCAvICggRFFVT1RFICpjb29raWUtb2N0ZXQgRFFVT1RFICkgfCAleDIxIC8gJXgyMy0yQiAvICV4MkQtM0EgLyAleDNDLTVCIC8gJXg1RC03RVxuICAgICAgICAgICAgaWYgKGNvb2tpZS52YWx1ZS5tYXRjaChjb29raWVWYWx1ZURRdW90ZVZhbGlkYXRlUmVnRXgpKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZENoYXIgPSBjb29raWUudmFsdWUuc2xpY2UoMSwgLTEpLm1hdGNoKGNvb2tpZVZhbHVlVmFsaWRhdGVSZWdFeCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmFsaWRDaGFyID0gY29va2llLnZhbHVlLm1hdGNoKGNvb2tpZVZhbHVlVmFsaWRhdGVSZWdFeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW52YWxpZENoYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgJyArIGludmFsaWRDaGFyWzBdICsgJyBpbiBjb29raWUgdmFsdWUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvb2tpZVBhcnRzID0gW2Nvb2tpZS5uYW1lICsgJz0nICsgY29va2llLnZhbHVlXTtcblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vICdQYXRoPScgcGF0aC12YWx1ZSB8IDxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciAnOyc+XG4gICAgICAgICAgICBpZihjb29raWUucGF0aCl7XG4gICAgICAgICAgICAgICAgaW52YWxpZENoYXIgPSBjb29raWUucGF0aC5tYXRjaChjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCk7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgJyArIGludmFsaWRDaGFyWzBdICsgJyBpbiBjb29raWUgcGF0aCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdQYXRoPScgKyBjb29raWUucGF0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4yLjNcbiAgICAgICAgICAgIC8vICdEb21haW49JyBzdWJkb21haW5cbiAgICAgICAgICAgIGlmIChjb29raWUuZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihjb29raWUuZG9tYWluKSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWplY3QoNTAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb21haW4gbXVzdCBiZSBzcGVjaWZpZWQgYW5kIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludmFsaWRDaGFyID0gY29va2llLmRvbWFpbi5tYXRjaChjb250cm9sQ2hhcnNBbmRTZW1pY29sb25SZWdFeCk7XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgJyArIGludmFsaWRDaGFyWzBdICsgJyBpbiBjb29raWUgZG9tYWluJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ0RvbWFpbj0nICsgY29va2llLmRvbWFpbi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vJ0V4cGlyZXM9JyBzYW5lLWNvb2tpZS1kYXRlIHwgRm9yY2UgRGF0ZSBvYmplY3QgcmVxdWlyZW1lbnQgYnkgdXNpbmcgb25seSBlcG9jaFxuICAgICAgICAgICAgaWYgKGNvb2tpZS5leHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY29va2llLmV4cGlyZXMgaW5zdGFuY2VvZiBEYXRlKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KDUwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgc3VwcGxpZWQgZm9yIGNvb2tpZSBcImV4cGlyZXNcIiBtdXN0IGJlIGEgdmFpbGQgZGF0ZSBvYmplY3QnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnRXhwaXJlcz0nICsgY29va2llLmV4cGlyZXMudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJGQyA2MjY1LCBTZWN0aW9uIDQuMS4xXG4gICAgICAgICAgICAvLydNYXgtQWdlPScgbm9uLXplcm8tZGlnaXQgKkRJR0lUXG4gICAgICAgICAgICBpZiAoY29va2llLm1heGFnZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhhZ2UgPSBjb29raWUubWF4YWdlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YobWF4YWdlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4YWdlID0gcGFyc2VJbnQobWF4YWdlLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc05hTihtYXhhZ2UpIHx8IG1heGFnZSA8PSAwICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBjb29raWUgXCJtYXhhZ2VcIiBtdXN0IGJlIGEgbm9uLXplcm8gbnVtYmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1heGFnZSA9IE1hdGgucm91bmQobWF4YWdlKTtcbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdNYXgtQWdlPScgKyBtYXhhZ2UudG9TdHJpbmcoMTApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vJ1NlY3VyZTsnXG4gICAgICAgICAgICBpZiAoY29va2llLnNlY3VyZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoY29va2llLnNlY3VyZSkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBjb29raWUgXCJzZWN1cmVcIiBtdXN0IGJlIG9mIHR5cGUgYm9vbGVhbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdTZWN1cmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUkZDIDYyNjUsIFNlY3Rpb24gNC4xLjFcbiAgICAgICAgICAgIC8vJ0h0dHBPbmx5OydcbiAgICAgICAgICAgIGlmIChjb29raWUuaHR0cG9ubHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKGNvb2tpZS5odHRwb25seSkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdCg1MDApO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHN1cHBsaWVkIGZvciBjb29raWUgXCJodHRwb25seVwiIG11c3QgYmUgb2YgdHlwZSBib29sZWFuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvb2tpZVBhcnRzLnB1c2goJ0h0dHBPbmx5Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3BvbnNlICs9ICgnU2V0LUNvb2tpZTogJyArIGNvb2tpZVBhcnRzLmpvaW4oJzsnKSArICdcXHJcXG4nKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBoYW5kbGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAgLy8gaWYgKG5lZ290aWF0ZWRFeHRlbnNpb25zKSB7XG4gICAgLy8gICAgIHJlc3BvbnNlICs9ICdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnM6ICcgKyBuZWdvdGlhdGVkRXh0ZW5zaW9ucy5qb2luKCcsICcpICsgJ1xcclxcbic7XG4gICAgLy8gfVxuXG4gICAgLy8gTWFyayB0aGUgcmVxdWVzdCByZXNvbHZlZCBub3cgc28gdGhhdCB0aGUgdXNlciBjYW4ndCBjYWxsIGFjY2VwdCBvclxuICAgIC8vIHJlamVjdCBhIHNlY29uZCB0aW1lLlxuICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RSZXNvbHZlZCcsIHRoaXMpO1xuXG4gICAgcmVzcG9uc2UgKz0gJ1xcclxcbic7XG5cbiAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMuc29ja2V0LCBbXSwgYWNjZXB0ZWRQcm90b2NvbCwgZmFsc2UsIHRoaXMuc2VydmVyQ29uZmlnKTtcbiAgICBjb25uZWN0aW9uLndlYlNvY2tldFZlcnNpb24gPSB0aGlzLndlYlNvY2tldFZlcnNpb247XG4gICAgY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzID0gdGhpcy5yZW1vdGVBZGRyZXNzO1xuICAgIGNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzc2VzID0gdGhpcy5yZW1vdGVBZGRyZXNzZXM7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fc29ja2V0SXNDbG9zaW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGhlIGNsaWVudCBoYW5ncyB1cCBiZWZvcmUgd2UgZ2V0IGEgY2hhbmNlIHRvXG4gICAgICAgIC8vIGFjY2VwdCB0aGUgY29ubmVjdGlvbiBhbmQgc2VuZCBvdXIgc2lkZSBvZiB0aGUgb3BlbmluZyBoYW5kc2hha2UuXG4gICAgICAgIGNsZWFudXBGYWlsZWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zb2NrZXQud3JpdGUocmVzcG9uc2UsICdhc2NpaScsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwRmFpbGVkQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuX3JlbW92ZVNvY2tldENsb3NlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl9hZGRTb2NrZXRFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RBY2NlcHRlZCcsIGNvbm5lY3Rpb24pO1xuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24oc3RhdHVzLCByZWFzb24sIGV4dHJhSGVhZGVycykge1xuICAgIHRoaXMuX3ZlcmlmeVJlc29sdXRpb24oKTtcblxuICAgIC8vIE1hcmsgdGhlIHJlcXVlc3QgcmVzb2x2ZWQgbm93IHNvIHRoYXQgdGhlIHVzZXIgY2FuJ3QgY2FsbCBhY2NlcHQgb3JcbiAgICAvLyByZWplY3QgYSBzZWNvbmQgdGltZS5cbiAgICB0aGlzLl9yZXNvbHZlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0UmVzb2x2ZWQnLCB0aGlzKTtcblxuICAgIGlmICh0eXBlb2Yoc3RhdHVzKSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgc3RhdHVzID0gNDAzO1xuICAgIH1cbiAgICB2YXIgcmVzcG9uc2UgPSAnSFRUUC8xLjEgJyArIHN0YXR1cyArICcgJyArIGh0dHBTdGF0dXNEZXNjcmlwdGlvbnNbc3RhdHVzXSArICdcXHJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnQ29ubmVjdGlvbjogY2xvc2VcXHJcXG4nO1xuICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgcmVhc29uID0gcmVhc29uLnJlcGxhY2UoaGVhZGVyU2FuaXRpemVSZWdFeHAsICcnKTtcbiAgICAgICAgcmVzcG9uc2UgKz0gJ1gtV2ViU29ja2V0LVJlamVjdC1SZWFzb246ICcgKyByZWFzb24gKyAnXFxyXFxuJztcbiAgICB9XG5cbiAgICBpZiAoZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBleHRyYUhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZWRWYWx1ZSA9IGV4dHJhSGVhZGVyc1trZXldLnRvU3RyaW5nKCkucmVwbGFjZShoZWFkZXJTYW5pdGl6ZVJlZ0V4cCwgJycpO1xuICAgICAgICAgICAgdmFyIHNhbml0aXplZEtleSA9IGtleS5yZXBsYWNlKGhlYWRlclNhbml0aXplUmVnRXhwLCAnJyk7XG4gICAgICAgICAgICByZXNwb25zZSArPSAoc2FuaXRpemVkS2V5ICsgJzogJyArIHNhbml0aXplZFZhbHVlICsgJ1xcclxcbicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzcG9uc2UgKz0gJ1xcclxcbic7XG4gICAgdGhpcy5zb2NrZXQuZW5kKHJlc3BvbnNlLCAnYXNjaWknKTtcblxuICAgIHRoaXMuZW1pdCgncmVxdWVzdFJlamVjdGVkJywgdGhpcyk7XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5faGFuZGxlU29ja2V0Q2xvc2VCZWZvcmVBY2NlcHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zb2NrZXRJc0Nsb3NpbmcgPSB0cnVlO1xuICAgIHRoaXMuX3JlbW92ZVNvY2tldENsb3NlTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRSZXF1ZXN0LnByb3RvdHlwZS5fcmVtb3ZlU29ja2V0Q2xvc2VMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignZW5kJywgdGhpcy5fc29ja2V0Q2xvc2VIYW5kbGVyKTtcbiAgICB0aGlzLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9zb2NrZXRDbG9zZUhhbmRsZXIpO1xufTtcblxuV2ViU29ja2V0UmVxdWVzdC5wcm90b3R5cGUuX3ZlcmlmeVJlc29sdXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXRSZXF1ZXN0IG1heSBvbmx5IGJlIGFjY2VwdGVkIG9yIHJlamVjdGVkIG9uZSB0aW1lLicpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGNsZWFudXBGYWlsZWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAvLyBTaW5jZSB3ZSBoYXZlIHRvIHJldHVybiBhIGNvbm5lY3Rpb24gb2JqZWN0IGV2ZW4gaWYgdGhlIHNvY2tldCBpc1xuICAgIC8vIGFscmVhZHkgZGVhZCBpbiBvcmRlciBub3QgdG8gYnJlYWsgdGhlIEFQSSwgd2Ugc2NoZWR1bGUgYSAnY2xvc2UnXG4gICAgLy8gZXZlbnQgb24gdGhlIGNvbm5lY3Rpb24gb2JqZWN0IHRvIG9jY3VyIGltbWVkaWF0ZWx5LlxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdlYlNvY2tldENvbm5lY3Rpb24uQ0xPU0VfUkVBU09OX0FCTk9STUFMID0gMTAwNlxuICAgICAgICAvLyBUaGlyZCBwYXJhbTogU2tpcCBzZW5kaW5nIHRoZSBjbG9zZSBmcmFtZSB0byBhIGRlYWQgc29ja2V0XG4gICAgICAgIGNvbm5lY3Rpb24uZHJvcCgxMDA2LCAnVENQIGNvbm5lY3Rpb24gbG9zdCBiZWZvcmUgaGFuZHNoYWtlIGNvbXBsZXRlZC4nLCB0cnVlKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRSZXF1ZXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketRouter.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouter.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\").extend);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRouterRequest = __webpack_require__(/*! ./WebSocketRouterRequest */ \"(ssr)/./node_modules/websocket/lib/WebSocketRouterRequest.js\");\n\nfunction WebSocketRouter(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.config = {\n        // The WebSocketServer instance to attach to.\n        server: null\n    };\n    if (config) {\n        extend(this.config, config);\n    }\n    this.handlers = [];\n\n    this._requestHandler = this.handleRequest.bind(this);\n    if (this.config.server) {\n        this.attachServer(this.config.server);\n    }\n}\n\nutil.inherits(WebSocketRouter, EventEmitter);\n\nWebSocketRouter.prototype.attachServer = function(server) {\n    if (server) {\n        this.server = server;\n        this.server.on('request', this._requestHandler);\n    }\n    else {\n        throw new Error('You must specify a WebSocketServer instance to attach to.');\n    }\n};\n\nWebSocketRouter.prototype.detachServer = function() {\n    if (this.server) {\n        this.server.removeListener('request', this._requestHandler);\n        this.server = null;\n    }\n    else {\n        throw new Error('Cannot detach from server: not attached.');\n    }\n};\n\nWebSocketRouter.prototype.mount = function(path, protocol, callback) {\n    if (!path) {\n        throw new Error('You must specify a path for this handler.');\n    }\n    if (!protocol) {\n        protocol = '____no_protocol____';\n    }\n    if (!callback) {\n        throw new Error('You must specify a callback for this handler.');\n    }\n\n    path = this.pathToRegExp(path);\n    if (!(path instanceof RegExp)) {\n        throw new Error('Path must be specified as either a string or a RegExp.');\n    }\n    var pathString = path.toString();\n\n    // normalize protocol to lower-case\n    protocol = protocol.toLocaleLowerCase();\n\n    if (this.findHandlerIndex(pathString, protocol) !== -1) {\n        throw new Error('You may only mount one handler per path/protocol combination.');\n    }\n\n    this.handlers.push({\n        'path': path,\n        'pathString': pathString,\n        'protocol': protocol,\n        'callback': callback\n    });\n};\nWebSocketRouter.prototype.unmount = function(path, protocol) {\n    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n    if (index !== -1) {\n        this.handlers.splice(index, 1);\n    }\n    else {\n        throw new Error('Unable to find a route matching the specified path and protocol.');\n    }\n};\n\nWebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {\n    protocol = protocol.toLocaleLowerCase();\n    for (var i=0, len=this.handlers.length; i < len; i++) {\n        var handler = this.handlers[i];\n        if (handler.pathString === pathString && handler.protocol === protocol) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nWebSocketRouter.prototype.pathToRegExp = function(path) {\n    if (typeof(path) === 'string') {\n        if (path === '*') {\n            path = /^.*$/;\n        }\n        else {\n            path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n            path = new RegExp('^' + path + '$');\n        }\n    }\n    return path;\n};\n\nWebSocketRouter.prototype.handleRequest = function(request) {\n    var requestedProtocols = request.requestedProtocols;\n    if (requestedProtocols.length === 0) {\n        requestedProtocols = ['____no_protocol____'];\n    }\n\n    // Find a handler with the first requested protocol first\n    for (var i=0; i < requestedProtocols.length; i++) {\n        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();\n\n        // find the first handler that can process this request\n        for (var j=0, len=this.handlers.length; j < len; j++) {\n            var handler = this.handlers[j];\n            if (handler.path.test(request.resourceURL.pathname)) {\n                if (requestedProtocol === handler.protocol ||\n                    handler.protocol === '*')\n                {\n                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n                    handler.callback(routerRequest);\n                    return;\n                }\n            }\n        }\n    }\n\n    // If we get here we were unable to find a suitable handler.\n    request.reject(404, 'No handler is available for the given request.');\n};\n\nmodule.exports = WebSocketRouter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsMEZBQXlCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixtQkFBbUIsMERBQThCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLDhGQUEwQjs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7O0FBRUE7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicHJvZGlnaWVzLWN5cHJlc3MvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXIuanM/ODNhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL3V0aWxzJykuZXh0ZW5kO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFdlYlNvY2tldFJvdXRlclJlcXVlc3QgPSByZXF1aXJlKCcuL1dlYlNvY2tldFJvdXRlclJlcXVlc3QnKTtcblxuZnVuY3Rpb24gV2ViU29ja2V0Um91dGVyKGNvbmZpZykge1xuICAgIC8vIFN1cGVyY2xhc3MgQ29uc3RydWN0b3JcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAvLyBUaGUgV2ViU29ja2V0U2VydmVyIGluc3RhbmNlIHRvIGF0dGFjaCB0by5cbiAgICAgICAgc2VydmVyOiBudWxsXG4gICAgfTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIGV4dGVuZCh0aGlzLmNvbmZpZywgY29uZmlnKTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuXG4gICAgdGhpcy5fcmVxdWVzdEhhbmRsZXIgPSB0aGlzLmhhbmRsZVJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICBpZiAodGhpcy5jb25maWcuc2VydmVyKSB7XG4gICAgICAgIHRoaXMuYXR0YWNoU2VydmVyKHRoaXMuY29uZmlnLnNlcnZlcik7XG4gICAgfVxufVxuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldFJvdXRlciwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5hdHRhY2hTZXJ2ZXIgPSBmdW5jdGlvbihzZXJ2ZXIpIHtcbiAgICBpZiAoc2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLnNlcnZlci5vbigncmVxdWVzdCcsIHRoaXMuX3JlcXVlc3RIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIFdlYlNvY2tldFNlcnZlciBpbnN0YW5jZSB0byBhdHRhY2ggdG8uJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5kZXRhY2hTZXJ2ZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCB0aGlzLl9yZXF1ZXN0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuc2VydmVyID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRldGFjaCBmcm9tIHNlcnZlcjogbm90IGF0dGFjaGVkLicpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbihwYXRoLCBwcm90b2NvbCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGEgcGF0aCBmb3IgdGhpcyBoYW5kbGVyLicpO1xuICAgIH1cbiAgICBpZiAoIXByb3RvY29sKSB7XG4gICAgICAgIHByb3RvY29sID0gJ19fX19ub19wcm90b2NvbF9fX18nO1xuICAgIH1cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGNhbGxiYWNrIGZvciB0aGlzIGhhbmRsZXIuJyk7XG4gICAgfVxuXG4gICAgcGF0aCA9IHRoaXMucGF0aFRvUmVnRXhwKHBhdGgpO1xuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYSBzdHJpbmcgb3IgYSBSZWdFeHAuJyk7XG4gICAgfVxuICAgIHZhciBwYXRoU3RyaW5nID0gcGF0aC50b1N0cmluZygpO1xuXG4gICAgLy8gbm9ybWFsaXplIHByb3RvY29sIHRvIGxvd2VyLWNhc2VcbiAgICBwcm90b2NvbCA9IHByb3RvY29sLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodGhpcy5maW5kSGFuZGxlckluZGV4KHBhdGhTdHJpbmcsIHByb3RvY29sKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG9ubHkgbW91bnQgb25lIGhhbmRsZXIgcGVyIHBhdGgvcHJvdG9jb2wgY29tYmluYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgICAgJ3BhdGgnOiBwYXRoLFxuICAgICAgICAncGF0aFN0cmluZyc6IHBhdGhTdHJpbmcsXG4gICAgICAgICdwcm90b2NvbCc6IHByb3RvY29sLFxuICAgICAgICAnY2FsbGJhY2snOiBjYWxsYmFja1xuICAgIH0pO1xufTtcbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uKHBhdGgsIHByb3RvY29sKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5maW5kSGFuZGxlckluZGV4KHRoaXMucGF0aFRvUmVnRXhwKHBhdGgpLnRvU3RyaW5nKCksIHByb3RvY29sKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgYSByb3V0ZSBtYXRjaGluZyB0aGUgc3BlY2lmaWVkIHBhdGggYW5kIHByb3RvY29sLicpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFJvdXRlci5wcm90b3R5cGUuZmluZEhhbmRsZXJJbmRleCA9IGZ1bmN0aW9uKHBhdGhTdHJpbmcsIHByb3RvY29sKSB7XG4gICAgcHJvdG9jb2wgPSBwcm90b2NvbC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGZvciAodmFyIGk9MCwgbGVuPXRoaXMuaGFuZGxlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2ldO1xuICAgICAgICBpZiAoaGFuZGxlci5wYXRoU3RyaW5nID09PSBwYXRoU3RyaW5nICYmIGhhbmRsZXIucHJvdG9jb2wgPT09IHByb3RvY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXIucHJvdG90eXBlLnBhdGhUb1JlZ0V4cCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAodHlwZW9mKHBhdGgpID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocGF0aCA9PT0gJyonKSB7XG4gICAgICAgICAgICBwYXRoID0gL14uKiQvO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgICAgICAgICAgIHBhdGggPSBuZXcgUmVnRXhwKCdeJyArIHBhdGggKyAnJCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuV2ViU29ja2V0Um91dGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHZhciByZXF1ZXN0ZWRQcm90b2NvbHMgPSByZXF1ZXN0LnJlcXVlc3RlZFByb3RvY29scztcbiAgICBpZiAocmVxdWVzdGVkUHJvdG9jb2xzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXF1ZXN0ZWRQcm90b2NvbHMgPSBbJ19fX19ub19wcm90b2NvbF9fX18nXTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGEgaGFuZGxlciB3aXRoIHRoZSBmaXJzdCByZXF1ZXN0ZWQgcHJvdG9jb2wgZmlyc3RcbiAgICBmb3IgKHZhciBpPTA7IGkgPCByZXF1ZXN0ZWRQcm90b2NvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlcXVlc3RlZFByb3RvY29sID0gcmVxdWVzdGVkUHJvdG9jb2xzW2ldLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgaGFuZGxlciB0aGF0IGNhbiBwcm9jZXNzIHRoaXMgcmVxdWVzdFxuICAgICAgICBmb3IgKHZhciBqPTAsIGxlbj10aGlzLmhhbmRsZXJzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuaGFuZGxlcnNbal07XG4gICAgICAgICAgICBpZiAoaGFuZGxlci5wYXRoLnRlc3QocmVxdWVzdC5yZXNvdXJjZVVSTC5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdGVkUHJvdG9jb2wgPT09IGhhbmRsZXIucHJvdG9jb2wgfHxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5wcm90b2NvbCA9PT0gJyonKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdXRlclJlcXVlc3QgPSBuZXcgV2ViU29ja2V0Um91dGVyUmVxdWVzdChyZXF1ZXN0LCByZXF1ZXN0ZWRQcm90b2NvbCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2socm91dGVyUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnZXQgaGVyZSB3ZSB3ZXJlIHVuYWJsZSB0byBmaW5kIGEgc3VpdGFibGUgaGFuZGxlci5cbiAgICByZXF1ZXN0LnJlamVjdCg0MDQsICdObyBoYW5kbGVyIGlzIGF2YWlsYWJsZSBmb3IgdGhlIGdpdmVuIHJlcXVlc3QuJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFJvdXRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketRouter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketRouterRequest.js":
/*!**************************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouterRequest.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nfunction WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.webSocketRequest = webSocketRequest;\n    if (resolvedProtocol === '____no_protocol____') {\n        this.protocol = null;\n    }\n    else {\n        this.protocol = resolvedProtocol;\n    }\n    this.origin = webSocketRequest.origin;\n    this.resource = webSocketRequest.resource;\n    this.resourceURL = webSocketRequest.resourceURL;\n    this.httpRequest = webSocketRequest.httpRequest;\n    this.remoteAddress = webSocketRequest.remoteAddress;\n    this.webSocketVersion = webSocketRequest.webSocketVersion;\n    this.requestedExtensions = webSocketRequest.requestedExtensions;\n    this.cookies = webSocketRequest.cookies;\n}\n\nutil.inherits(WebSocketRouterRequest, EventEmitter);\n\nWebSocketRouterRequest.prototype.accept = function(origin, cookies) {\n    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);\n    this.emit('requestAccepted', connection);\n    return connection;\n};\n\nWebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this.webSocketRequest.reject(status, reason, extraHeaders);\n    this.emit('requestRejected', this);\n};\n\nmodule.exports = WebSocketRouterRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsbUJBQW1CLDBEQUE4Qjs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL1dlYlNvY2tldFJvdXRlclJlcXVlc3QuanM/YmNiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuZnVuY3Rpb24gV2ViU29ja2V0Um91dGVyUmVxdWVzdCh3ZWJTb2NrZXRSZXF1ZXN0LCByZXNvbHZlZFByb3RvY29sKSB7XG4gICAgLy8gU3VwZXJjbGFzcyBDb25zdHJ1Y3RvclxuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy53ZWJTb2NrZXRSZXF1ZXN0ID0gd2ViU29ja2V0UmVxdWVzdDtcbiAgICBpZiAocmVzb2x2ZWRQcm90b2NvbCA9PT0gJ19fX19ub19wcm90b2NvbF9fX18nKSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHJlc29sdmVkUHJvdG9jb2w7XG4gICAgfVxuICAgIHRoaXMub3JpZ2luID0gd2ViU29ja2V0UmVxdWVzdC5vcmlnaW47XG4gICAgdGhpcy5yZXNvdXJjZSA9IHdlYlNvY2tldFJlcXVlc3QucmVzb3VyY2U7XG4gICAgdGhpcy5yZXNvdXJjZVVSTCA9IHdlYlNvY2tldFJlcXVlc3QucmVzb3VyY2VVUkw7XG4gICAgdGhpcy5odHRwUmVxdWVzdCA9IHdlYlNvY2tldFJlcXVlc3QuaHR0cFJlcXVlc3Q7XG4gICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gd2ViU29ja2V0UmVxdWVzdC5yZW1vdGVBZGRyZXNzO1xuICAgIHRoaXMud2ViU29ja2V0VmVyc2lvbiA9IHdlYlNvY2tldFJlcXVlc3Qud2ViU29ja2V0VmVyc2lvbjtcbiAgICB0aGlzLnJlcXVlc3RlZEV4dGVuc2lvbnMgPSB3ZWJTb2NrZXRSZXF1ZXN0LnJlcXVlc3RlZEV4dGVuc2lvbnM7XG4gICAgdGhpcy5jb29raWVzID0gd2ViU29ja2V0UmVxdWVzdC5jb29raWVzO1xufVxuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldFJvdXRlclJlcXVlc3QsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFJvdXRlclJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKG9yaWdpbiwgY29va2llcykge1xuICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy53ZWJTb2NrZXRSZXF1ZXN0LmFjY2VwdCh0aGlzLnByb3RvY29sLCBvcmlnaW4sIGNvb2tpZXMpO1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdEFjY2VwdGVkJywgY29ubmVjdGlvbik7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG59O1xuXG5XZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0LnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihzdGF0dXMsIHJlYXNvbiwgZXh0cmFIZWFkZXJzKSB7XG4gICAgdGhpcy53ZWJTb2NrZXRSZXF1ZXN0LnJlamVjdChzdGF0dXMsIHJlYXNvbiwgZXh0cmFIZWFkZXJzKTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3RSZWplY3RlZCcsIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRSb3V0ZXJSZXF1ZXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketRouterRequest.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/WebSocketServer.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketServer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\").extend);\nvar utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar debug = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/index.js\")('websocket:server');\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar WebSocketRequest = __webpack_require__(/*! ./WebSocketRequest */ \"(ssr)/./node_modules/websocket/lib/WebSocketRequest.js\");\n\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\n\nutil.inherits(WebSocketServer, EventEmitter);\n\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n\n        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n        parseCookies: true,\n\n        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n        parseExtensions: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [this.config.httpServer];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on('upgrade', upgradeHandler);\n        });\n    }\n    else {\n        throw new Error('You must specify an httpServer on which to mount the WebSocket server.');\n    }\n};\n\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener('upgrade', upgradeHandler);\n    });\n};\n\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n          request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\n\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    }\n    else if (typeof(data.toString) === 'function') {\n        this.broadcastUTF(data);\n    }\n};\n\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\n\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\n\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\n\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var self = this;\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    }\n    catch(e) {\n        wsRequest.reject(\n            e.httpCode ? e.httpCode : 400,\n            e.message,\n            e.headers\n        );\n        debug('Invalid handshake: %s', e.message);\n        this.emit('upgradeError', e);\n        return;\n    }\n\n    this.pendingRequests.push(wsRequest);\n\n    wsRequest.once('requestAccepted', this._handlers.requestAccepted);\n    wsRequest.once('requestResolved', this._handlers.requestResolved);\n    socket.once('close', function () {\n        self._handlers.requestResolved(wsRequest);\n    });\n\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {\n        this.emit('request', wsRequest);\n    }\n    else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    }\n    else {\n        wsRequest.reject(404, 'No handler is configured to accept the connection.');\n    }\n};\n\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once('close', function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit('connect', connection);\n};\n\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit('close', connection, closeReason, description);\n};\n\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) { this.pendingRequests.splice(index, 1); }\n};\n\nmodule.exports = WebSocketServer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRTZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsMEZBQXlCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyw0REFBUztBQUM3QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLDZFQUFPO0FBQzNCLG1CQUFtQiwwREFBOEI7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQW9COztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicHJvZGlnaWVzLWN5cHJlc3MvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9XZWJTb2NrZXRTZXJ2ZXIuanM/YTE5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ29weXJpZ2h0IDIwMTAtMjAxNSBCcmlhbiBNY0tlbHZleS5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCcuL3V0aWxzJykuZXh0ZW5kO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCd3ZWJzb2NrZXQ6c2VydmVyJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFdlYlNvY2tldFJlcXVlc3QgPSByZXF1aXJlKCcuL1dlYlNvY2tldFJlcXVlc3QnKTtcblxudmFyIFdlYlNvY2tldFNlcnZlciA9IGZ1bmN0aW9uIFdlYlNvY2tldFNlcnZlcihjb25maWcpIHtcbiAgICAvLyBTdXBlcmNsYXNzIENvbnN0cnVjdG9yXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9oYW5kbGVycyA9IHtcbiAgICAgICAgdXBncmFkZTogdGhpcy5oYW5kbGVVcGdyYWRlLmJpbmQodGhpcyksXG4gICAgICAgIHJlcXVlc3RBY2NlcHRlZDogdGhpcy5oYW5kbGVSZXF1ZXN0QWNjZXB0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgcmVxdWVzdFJlc29sdmVkOiB0aGlzLmhhbmRsZVJlcXVlc3RSZXNvbHZlZC5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLmNvbm5lY3Rpb25zID0gW107XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMgPSBbXTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICAgIHRoaXMubW91bnQoY29uZmlnKTtcbiAgICB9XG59O1xuXG51dGlsLmluaGVyaXRzKFdlYlNvY2tldFNlcnZlciwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAvLyBUaGUgaHR0cCBzZXJ2ZXIgaW5zdGFuY2UgdG8gYXR0YWNoIHRvLiAgUmVxdWlyZWQuXG4gICAgICAgIGh0dHBTZXJ2ZXI6IG51bGwsXG5cbiAgICAgICAgLy8gNjRLaUIgbWF4IGZyYW1lIHNpemUuXG4gICAgICAgIG1heFJlY2VpdmVkRnJhbWVTaXplOiAweDEwMDAwLFxuXG4gICAgICAgIC8vIDFNaUIgbWF4IG1lc3NhZ2Ugc2l6ZSwgb25seSBhcHBsaWNhYmxlIGlmXG4gICAgICAgIC8vIGFzc2VtYmxlRnJhZ21lbnRzIGlzIHRydWVcbiAgICAgICAgbWF4UmVjZWl2ZWRNZXNzYWdlU2l6ZTogMHgxMDAwMDAsXG5cbiAgICAgICAgLy8gT3V0Z29pbmcgbWVzc2FnZXMgbGFyZ2VyIHRoYW4gZnJhZ21lbnRhdGlvblRocmVzaG9sZCB3aWxsIGJlXG4gICAgICAgIC8vIHNwbGl0IGludG8gbXVsdGlwbGUgZnJhZ21lbnRzLlxuICAgICAgICBmcmFnbWVudE91dGdvaW5nTWVzc2FnZXM6IHRydWUsXG5cbiAgICAgICAgLy8gT3V0Z29pbmcgZnJhbWVzIGFyZSBmcmFnbWVudGVkIGlmIHRoZXkgZXhjZWVkIHRoaXMgdGhyZXNob2xkLlxuICAgICAgICAvLyBEZWZhdWx0IGlzIDE2S2lCXG4gICAgICAgIGZyYWdtZW50YXRpb25UaHJlc2hvbGQ6IDB4NDAwMCxcblxuICAgICAgICAvLyBJZiB0cnVlLCB0aGUgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseSBzZW5kIGEgcGluZyB0byBhbGxcbiAgICAgICAgLy8gY2xpZW50cyBldmVyeSAna2VlcGFsaXZlSW50ZXJ2YWwnIG1pbGxpc2Vjb25kcy4gIFRoZSB0aW1lciBpc1xuICAgICAgICAvLyByZXNldCBvbiBhbnkgcmVjZWl2ZWQgZGF0YSBmcm9tIHRoZSBjbGllbnQuXG4gICAgICAgIGtlZXBhbGl2ZTogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgaW50ZXJ2YWwgdG8gc2VuZCBrZWVwYWxpdmUgcGluZ3MgdG8gY29ubmVjdGVkIGNsaWVudHMgaWYgdGhlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgaWRsZS4gIEFueSByZWNlaXZlZCBkYXRhIHdpbGwgcmVzZXQgdGhlIGNvdW50ZXIuXG4gICAgICAgIGtlZXBhbGl2ZUludGVydmFsOiAyMDAwMCxcblxuICAgICAgICAvLyBJZiB0cnVlLCB0aGUgc2VydmVyIHdpbGwgY29uc2lkZXIgYW55IGNvbm5lY3Rpb24gdGhhdCBoYXMgbm90XG4gICAgICAgIC8vIHJlY2VpdmVkIGFueSBkYXRhIHdpdGhpbiB0aGUgYW1vdW50IG9mIHRpbWUgc3BlY2lmaWVkIGJ5XG4gICAgICAgIC8vICdrZWVwYWxpdmVHcmFjZVBlcmlvZCcgYWZ0ZXIgYSBrZWVwYWxpdmUgcGluZyBoYXMgYmVlbiBzZW50IHRvXG4gICAgICAgIC8vIGJlIGRlYWQsIGFuZCB3aWxsIGRyb3AgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgIC8vIElnbm9yZWQgaWYga2VlcGFsaXZlIGlzIGZhbHNlLlxuICAgICAgICBkcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dDogdHJ1ZSxcblxuICAgICAgICAvLyBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBhZnRlciBzZW5kaW5nIGEga2VlcGFsaXZlIHBpbmcgYmVmb3JlXG4gICAgICAgIC8vIGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24gaWYgdGhlIGNvbm5lY3RlZCBwZWVyIGRvZXMgbm90IHJlc3BvbmQuXG4gICAgICAgIC8vIElnbm9yZWQgaWYga2VlcGFsaXZlIGlzIGZhbHNlLlxuICAgICAgICBrZWVwYWxpdmVHcmFjZVBlcmlvZDogMTAwMDAsXG5cbiAgICAgICAgLy8gV2hldGhlciB0byB1c2UgbmF0aXZlIFRDUCBrZWVwLWFsaXZlIGluc3RlYWQgb2YgV2ViU29ja2V0cyBwaW5nXG4gICAgICAgIC8vIGFuZCBwb25nIHBhY2tldHMuICBOYXRpdmUgVENQIGtlZXAtYWxpdmUgc2VuZHMgc21hbGxlciBwYWNrZXRzXG4gICAgICAgIC8vIG9uIHRoZSB3aXJlIGFuZCBzbyB1c2VzIGJhbmR3aWR0aCBtb3JlIGVmZmljaWVudGx5LiAgVGhpcyBtYXlcbiAgICAgICAgLy8gYmUgbW9yZSBpbXBvcnRhbnQgd2hlbiB0YWxraW5nIHRvIG1vYmlsZSBkZXZpY2VzLlxuICAgICAgICAvLyBJZiB0aGlzIHZhbHVlIGlzIHNldCB0byB0cnVlLCB0aGVuIHRoZXNlIHZhbHVlcyB3aWxsIGJlIGlnbm9yZWQ6XG4gICAgICAgIC8vICAga2VlcGFsaXZlR3JhY2VQZXJpb2RcbiAgICAgICAgLy8gICBkcm9wQ29ubmVjdGlvbk9uS2VlcGFsaXZlVGltZW91dFxuICAgICAgICB1c2VOYXRpdmVLZWVwYWxpdmU6IGZhbHNlLFxuXG4gICAgICAgIC8vIElmIHRydWUsIGZyYWdtZW50ZWQgbWVzc2FnZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGFzc2VtYmxlZFxuICAgICAgICAvLyBhbmQgdGhlIGZ1bGwgbWVzc2FnZSB3aWxsIGJlIGVtaXR0ZWQgdmlhIGEgJ21lc3NhZ2UnIGV2ZW50LlxuICAgICAgICAvLyBJZiBmYWxzZSwgZWFjaCBmcmFtZSB3aWxsIGJlIGVtaXR0ZWQgdmlhIGEgJ2ZyYW1lJyBldmVudCBhbmRcbiAgICAgICAgLy8gdGhlIGFwcGxpY2F0aW9uIHdpbGwgYmUgcmVzcG9uc2libGUgZm9yIGFnZ3JlZ2F0aW5nIG11bHRpcGxlXG4gICAgICAgIC8vIGZyYWdtZW50ZWQgZnJhbWVzLiAgU2luZ2xlLWZyYW1lIG1lc3NhZ2VzIHdpbGwgZW1pdCBhICdtZXNzYWdlJ1xuICAgICAgICAvLyBldmVudCBpbiBhZGRpdGlvbiB0byB0aGUgJ2ZyYW1lJyBldmVudC5cbiAgICAgICAgLy8gTW9zdCB1c2VycyB3aWxsIHdhbnQgdG8gbGVhdmUgdGhpcyBzZXQgdG8gJ3RydWUnXG4gICAgICAgIGFzc2VtYmxlRnJhZ21lbnRzOiB0cnVlLFxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdHJ1ZSwgd2Vic29ja2V0IGNvbm5lY3Rpb25zIHdpbGwgYmUgYWNjZXB0ZWRcbiAgICAgICAgLy8gcmVnYXJkbGVzcyBvZiB0aGUgcGF0aCBhbmQgcHJvdG9jb2wgc3BlY2lmaWVkIGJ5IHRoZSBjbGllbnQuXG4gICAgICAgIC8vIFRoZSBwcm90b2NvbCBhY2NlcHRlZCB3aWxsIGJlIHRoZSBmaXJzdCB0aGF0IHdhcyByZXF1ZXN0ZWRcbiAgICAgICAgLy8gYnkgdGhlIGNsaWVudC4gIENsaWVudHMgZnJvbSBhbnkgb3JpZ2luIHdpbGwgYmUgYWNjZXB0ZWQuXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiB0aGUgc2ltcGxlc3Qgb2YgY2FzZXMuICBZb3Ugc2hvdWxkXG4gICAgICAgIC8vIHByb2JhYmx5IGxlYXZlIHRoaXMgc2V0IHRvICdmYWxzZScgYW5kIGluc3BlY3QgdGhlIHJlcXVlc3RcbiAgICAgICAgLy8gb2JqZWN0IHRvIG1ha2Ugc3VyZSBpdCdzIGFjY2VwdGFibGUgYmVmb3JlIGFjY2VwdGluZyBpdC5cbiAgICAgICAgYXV0b0FjY2VwdENvbm5lY3Rpb25zOiBmYWxzZSxcblxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCB0aGUgWC1Gb3J3YXJkZWQtRm9yIGhlYWRlciBzaG91bGQgYmUgcmVzcGVjdGVkLlxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBzZXQgdGhpcyB0byAndHJ1ZScgd2hlbiBhY2NlcHRpbmcgY29ubmVjdGlvbnNcbiAgICAgICAgLy8gZnJvbSB1bnRydXN0ZWQgY2xpZW50cywgYXMgYSBtYWxpY2lvdXMgY2xpZW50IGNvdWxkIHNwb29mIGl0c1xuICAgICAgICAvLyBJUCBhZGRyZXNzIGJ5IHNpbXBseSBzZXR0aW5nIHRoaXMgaGVhZGVyLiAgSXQncyBtZWFudCB0byBiZSBhZGRlZFxuICAgICAgICAvLyBieSBhIHRydXN0ZWQgcHJveHkgb3Igb3RoZXIgaW50ZXJtZWRpYXJ5IHdpdGhpbiB5b3VyIG93blxuICAgICAgICAvLyBpbmZyYXN0cnVjdHVyZS5cbiAgICAgICAgLy8gU2VlOiAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9YLUZvcndhcmRlZC1Gb3JcbiAgICAgICAgaWdub3JlWEZvcndhcmRlZEZvcjogZmFsc2UsXG5cbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0cnVlLCAnY29va2llJyBoZWFkZXJzIGFyZSBwYXJzZWQgYW5kIGV4cG9zZWQgYXMgV2ViU29ja2V0UmVxdWVzdC5jb29raWVzXG4gICAgICAgIHBhcnNlQ29va2llczogdHJ1ZSxcblxuICAgICAgICAvLyBJZiB0aGlzIGlzIHRydWUsICdzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnMnIGhlYWRlcnMgYXJlIHBhcnNlZCBhbmQgZXhwb3NlZCBhcyBXZWJTb2NrZXRSZXF1ZXN0LnJlcXVlc3RlZEV4dGVuc2lvbnNcbiAgICAgICAgcGFyc2VFeHRlbnNpb25zOiB0cnVlLFxuXG4gICAgICAgIC8vIFRoZSBOYWdsZSBBbGdvcml0aG0gbWFrZXMgbW9yZSBlZmZpY2llbnQgdXNlIG9mIG5ldHdvcmsgcmVzb3VyY2VzXG4gICAgICAgIC8vIGJ5IGludHJvZHVjaW5nIGEgc21hbGwgZGVsYXkgYmVmb3JlIHNlbmRpbmcgc21hbGwgcGFja2V0cyBzbyB0aGF0XG4gICAgICAgIC8vIG11bHRpcGxlIG1lc3NhZ2VzIGNhbiBiZSBiYXRjaGVkIHRvZ2V0aGVyIGJlZm9yZSBnb2luZyBvbnRvIHRoZVxuICAgICAgICAvLyB3aXJlLiAgVGhpcyBob3dldmVyIGNvbWVzIGF0IHRoZSBjb3N0IG9mIGxhdGVuY3ksIHNvIHRoZSBkZWZhdWx0XG4gICAgICAgIC8vIGlzIHRvIGRpc2FibGUgaXQuICBJZiB5b3UgZG9uJ3QgbmVlZCBsb3cgbGF0ZW5jeSBhbmQgYXJlIHN0cmVhbWluZ1xuICAgICAgICAvLyBsb3RzIG9mIHNtYWxsIG1lc3NhZ2VzLCB5b3UgY2FuIGNoYW5nZSB0aGlzIHRvICdmYWxzZSdcbiAgICAgICAgZGlzYWJsZU5hZ2xlQWxnb3JpdGhtOiB0cnVlLFxuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYWZ0ZXIgc2VuZGluZyBhIGNsb3NlIGZyYW1lXG4gICAgICAgIC8vIGZvciBhbiBhY2tub3dsZWRnZW1lbnQgdG8gY29tZSBiYWNrIGJlZm9yZSBnaXZpbmcgdXAgYW5kIGp1c3RcbiAgICAgICAgLy8gY2xvc2luZyB0aGUgc29ja2V0LlxuICAgICAgICBjbG9zZVRpbWVvdXQ6IDUwMDBcbiAgICB9O1xuICAgIGV4dGVuZCh0aGlzLmNvbmZpZywgY29uZmlnKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5odHRwU2VydmVyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmNvbmZpZy5odHRwU2VydmVyKSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuaHR0cFNlcnZlciA9IFt0aGlzLmNvbmZpZy5odHRwU2VydmVyXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBncmFkZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVycy51cGdyYWRlO1xuICAgICAgICB0aGlzLmNvbmZpZy5odHRwU2VydmVyLmZvckVhY2goZnVuY3Rpb24oaHR0cFNlcnZlcikge1xuICAgICAgICAgICAgaHR0cFNlcnZlci5vbigndXBncmFkZScsIHVwZ3JhZGVIYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYW4gaHR0cFNlcnZlciBvbiB3aGljaCB0byBtb3VudCB0aGUgV2ViU29ja2V0IHNlcnZlci4nKTtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXBncmFkZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVycy51cGdyYWRlO1xuICAgIHRoaXMuY29uZmlnLmh0dHBTZXJ2ZXIuZm9yRWFjaChmdW5jdGlvbihodHRwU2VydmVyKSB7XG4gICAgICAgIGh0dHBTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCB1cGdyYWRlSGFuZGxlcik7XG4gICAgfSk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmNsb3NlQWxsQ29ubmVjdGlvbnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVxdWVzdC5yZWplY3QoNTAzKTsgLy8gSFRUUCA1MDMgU2VydmljZSBVbmF2YWlsYWJsZVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuYnJvYWRjYXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RCeXRlcyhkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mKGRhdGEudG9TdHJpbmcpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0VVRGKGRhdGEpO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuYnJvYWRjYXN0VVRGID0gZnVuY3Rpb24odXRmRGF0YSkge1xuICAgIHRoaXMuY29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc2VuZFVURih1dGZEYXRhKTtcbiAgICB9KTtcbn07XG5cbldlYlNvY2tldFNlcnZlci5wcm90b3R5cGUuYnJvYWRjYXN0Qnl0ZXMgPSBmdW5jdGlvbihiaW5hcnlEYXRhKSB7XG4gICAgdGhpcy5jb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29ubmVjdGlvbi5zZW5kQnl0ZXMoYmluYXJ5RGF0YSk7XG4gICAgfSk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLnNodXREb3duID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51bm1vdW50KCk7XG4gICAgdGhpcy5jbG9zZUFsbENvbm5lY3Rpb25zKCk7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmhhbmRsZVVwZ3JhZGUgPSBmdW5jdGlvbihyZXF1ZXN0LCBzb2NrZXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdzUmVxdWVzdCA9IG5ldyBXZWJTb2NrZXRSZXF1ZXN0KHNvY2tldCwgcmVxdWVzdCwgdGhpcy5jb25maWcpO1xuICAgIHRyeSB7XG4gICAgICAgIHdzUmVxdWVzdC5yZWFkSGFuZHNoYWtlKCk7XG4gICAgfVxuICAgIGNhdGNoKGUpIHtcbiAgICAgICAgd3NSZXF1ZXN0LnJlamVjdChcbiAgICAgICAgICAgIGUuaHR0cENvZGUgPyBlLmh0dHBDb2RlIDogNDAwLFxuICAgICAgICAgICAgZS5tZXNzYWdlLFxuICAgICAgICAgICAgZS5oZWFkZXJzXG4gICAgICAgICk7XG4gICAgICAgIGRlYnVnKCdJbnZhbGlkIGhhbmRzaGFrZTogJXMnLCBlLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMucHVzaCh3c1JlcXVlc3QpO1xuXG4gICAgd3NSZXF1ZXN0Lm9uY2UoJ3JlcXVlc3RBY2NlcHRlZCcsIHRoaXMuX2hhbmRsZXJzLnJlcXVlc3RBY2NlcHRlZCk7XG4gICAgd3NSZXF1ZXN0Lm9uY2UoJ3JlcXVlc3RSZXNvbHZlZCcsIHRoaXMuX2hhbmRsZXJzLnJlcXVlc3RSZXNvbHZlZCk7XG4gICAgc29ja2V0Lm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9oYW5kbGVycy5yZXF1ZXN0UmVzb2x2ZWQod3NSZXF1ZXN0KTtcbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5jb25maWcuYXV0b0FjY2VwdENvbm5lY3Rpb25zICYmIHV0aWxzLmV2ZW50RW1pdHRlckxpc3RlbmVyQ291bnQodGhpcywgJ3JlcXVlc3QnKSA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0Jywgd3NSZXF1ZXN0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5jb25maWcuYXV0b0FjY2VwdENvbm5lY3Rpb25zKSB7XG4gICAgICAgIHdzUmVxdWVzdC5hY2NlcHQod3NSZXF1ZXN0LnJlcXVlc3RlZFByb3RvY29sc1swXSwgd3NSZXF1ZXN0Lm9yaWdpbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3c1JlcXVlc3QucmVqZWN0KDQwNCwgJ05vIGhhbmRsZXIgaXMgY29uZmlndXJlZCB0byBhY2NlcHQgdGhlIGNvbm5lY3Rpb24uJyk7XG4gICAgfVxufTtcblxuV2ViU29ja2V0U2VydmVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0QWNjZXB0ZWQgPSBmdW5jdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGNvbm5lY3Rpb24ub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjbG9zZVJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgc2VsZi5oYW5kbGVDb25uZWN0aW9uQ2xvc2UoY29ubmVjdGlvbiwgY2xvc2VSZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbm5lY3Rpb25zLnB1c2goY29ubmVjdGlvbik7XG4gICAgdGhpcy5lbWl0KCdjb25uZWN0JywgY29ubmVjdGlvbik7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmhhbmRsZUNvbm5lY3Rpb25DbG9zZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIGNsb3NlUmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29ubmVjdGlvbnMuaW5kZXhPZihjb25uZWN0aW9uKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNvbm5lY3Rpb24sIGNsb3NlUmVhc29uLCBkZXNjcmlwdGlvbik7XG59O1xuXG5XZWJTb2NrZXRTZXJ2ZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3RSZXNvbHZlZCA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5pbmRleE9mKHJlcXVlc3QpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHsgdGhpcy5wZW5kaW5nUmVxdWVzdHMuc3BsaWNlKGluZGV4LCAxKTsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRTZXJ2ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/WebSocketServer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/websocket/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var noop = exports.noop = function(){};\n\nexports.extend = function extend(dest, source) {\n    for (var prop in source) {\n        dest[prop] = source[prop];\n    }\n};\n\nexports.eventEmitterListenerCount =\n    (__webpack_require__(/*! events */ \"events\").EventEmitter.listenerCount) ||\n    function(emitter, type) { return emitter.listeners(type).length; };\n\nexports.bufferAllocUnsafe = Buffer.allocUnsafe ?\n    Buffer.allocUnsafe :\n    function oldBufferAllocUnsafe(size) { return new Buffer(size); };\n\nexports.bufferFromString = Buffer.from ?\n    Buffer.from :\n    function oldBufferFromString(string, encoding) {\n      return new Buffer(string, encoding);\n    };\n\nexports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {\n    var logFunction = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/index.js\")(identifier);\n    if (logFunction.enabled) {\n        var logger = new BufferingLogger(identifier, uniqueID, logFunction);\n        var debug = logger.log.bind(logger);\n        debug.printOutput = logger.printOutput.bind(logger);\n        debug.enabled = logFunction.enabled;\n        return debug;\n    }\n    logFunction.printOutput = noop;\n    return logFunction;\n};\n\nfunction BufferingLogger(identifier, uniqueID, logFunction) {\n    this.logFunction = logFunction;\n    this.identifier = identifier;\n    this.uniqueID = uniqueID;\n    this.buffer = [];\n}\n\nBufferingLogger.prototype.log = function() {\n  this.buffer.push([ new Date(), Array.prototype.slice.call(arguments) ]);\n  return this;\n};\n\nBufferingLogger.prototype.clear = function() {\n  this.buffer = [];\n  return this;\n};\n\nBufferingLogger.prototype.printOutput = function(logFunction) {\n    if (!logFunction) { logFunction = this.logFunction; }\n    var uniqueID = this.uniqueID;\n    this.buffer.forEach(function(entry) {\n        var date = entry[0].toLocaleString();\n        var args = entry[1].slice();\n        var formatString = args[0];\n        if (formatString !== (void 0) && formatString !== null) {\n            formatString = '%s - %s - ' + formatString.toString();\n            args.splice(0, 1, formatString, date, uniqueID);\n            logFunction.apply(global, args);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLFlBQVk7O0FBRXZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsSUFBSSx3RUFBNEM7QUFDaEQsOEJBQThCOztBQUU5Qix5QkFBeUI7QUFDekI7QUFDQSwwQ0FBMEM7O0FBRTFDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsc0JBQXNCLG1CQUFPLENBQUMsNkVBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VicHJvZGlnaWVzLWN5cHJlc3MvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi91dGlscy5qcz85MjBhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBub29wID0gZXhwb3J0cy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBkZXN0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZXZlbnRFbWl0dGVyTGlzdGVuZXJDb3VudCA9XG4gICAgcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgfHxcbiAgICBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7IHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7IH07XG5cbmV4cG9ydHMuYnVmZmVyQWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgP1xuICAgIEJ1ZmZlci5hbGxvY1Vuc2FmZSA6XG4gICAgZnVuY3Rpb24gb2xkQnVmZmVyQWxsb2NVbnNhZmUoc2l6ZSkgeyByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTsgfTtcblxuZXhwb3J0cy5idWZmZXJGcm9tU3RyaW5nID0gQnVmZmVyLmZyb20gP1xuICAgIEJ1ZmZlci5mcm9tIDpcbiAgICBmdW5jdGlvbiBvbGRCdWZmZXJGcm9tU3RyaW5nKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgQnVmZmVyKHN0cmluZywgZW5jb2RpbmcpO1xuICAgIH07XG5cbmV4cG9ydHMuQnVmZmVyaW5nTG9nZ2VyID0gZnVuY3Rpb24gY3JlYXRlQnVmZmVyaW5nTG9nZ2VyKGlkZW50aWZpZXIsIHVuaXF1ZUlEKSB7XG4gICAgdmFyIGxvZ0Z1bmN0aW9uID0gcmVxdWlyZSgnZGVidWcnKShpZGVudGlmaWVyKTtcbiAgICBpZiAobG9nRnVuY3Rpb24uZW5hYmxlZCkge1xuICAgICAgICB2YXIgbG9nZ2VyID0gbmV3IEJ1ZmZlcmluZ0xvZ2dlcihpZGVudGlmaWVyLCB1bmlxdWVJRCwgbG9nRnVuY3Rpb24pO1xuICAgICAgICB2YXIgZGVidWcgPSBsb2dnZXIubG9nLmJpbmQobG9nZ2VyKTtcbiAgICAgICAgZGVidWcucHJpbnRPdXRwdXQgPSBsb2dnZXIucHJpbnRPdXRwdXQuYmluZChsb2dnZXIpO1xuICAgICAgICBkZWJ1Zy5lbmFibGVkID0gbG9nRnVuY3Rpb24uZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIGRlYnVnO1xuICAgIH1cbiAgICBsb2dGdW5jdGlvbi5wcmludE91dHB1dCA9IG5vb3A7XG4gICAgcmV0dXJuIGxvZ0Z1bmN0aW9uO1xufTtcblxuZnVuY3Rpb24gQnVmZmVyaW5nTG9nZ2VyKGlkZW50aWZpZXIsIHVuaXF1ZUlELCBsb2dGdW5jdGlvbikge1xuICAgIHRoaXMubG9nRnVuY3Rpb24gPSBsb2dGdW5jdGlvbjtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgIHRoaXMudW5pcXVlSUQgPSB1bmlxdWVJRDtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xufVxuXG5CdWZmZXJpbmdMb2dnZXIucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmJ1ZmZlci5wdXNoKFsgbmV3IERhdGUoKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSBdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CdWZmZXJpbmdMb2dnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYnVmZmVyID0gW107XG4gIHJldHVybiB0aGlzO1xufTtcblxuQnVmZmVyaW5nTG9nZ2VyLnByb3RvdHlwZS5wcmludE91dHB1dCA9IGZ1bmN0aW9uKGxvZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKCFsb2dGdW5jdGlvbikgeyBsb2dGdW5jdGlvbiA9IHRoaXMubG9nRnVuY3Rpb247IH1cbiAgICB2YXIgdW5pcXVlSUQgPSB0aGlzLnVuaXF1ZUlEO1xuICAgIHRoaXMuYnVmZmVyLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgdmFyIGRhdGUgPSBlbnRyeVswXS50b0xvY2FsZVN0cmluZygpO1xuICAgICAgICB2YXIgYXJncyA9IGVudHJ5WzFdLnNsaWNlKCk7XG4gICAgICAgIHZhciBmb3JtYXRTdHJpbmcgPSBhcmdzWzBdO1xuICAgICAgICBpZiAoZm9ybWF0U3RyaW5nICE9PSAodm9pZCAwKSAmJiBmb3JtYXRTdHJpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZyA9ICclcyAtICVzIC0gJyArIGZvcm1hdFN0cmluZy50b1N0cmluZygpO1xuICAgICAgICAgICAgYXJncy5zcGxpY2UoMCwgMSwgZm9ybWF0U3RyaW5nLCBkYXRlLCB1bmlxdWVJRCk7XG4gICAgICAgICAgICBsb2dGdW5jdGlvbi5hcHBseShnbG9iYWwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ../package.json */ \"(ssr)/./node_modules/websocket/package.json\").version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtIQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnByb2RpZ2llcy1jeXByZXNzLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvdmVyc2lvbi5qcz8yNmNmIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/lib/websocket.js":
/*!*************************************************!*\
  !*** ./node_modules/websocket/lib/websocket.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = {\n    'server'       : __webpack_require__(/*! ./WebSocketServer */ \"(ssr)/./node_modules/websocket/lib/WebSocketServer.js\"),\n    'client'       : __webpack_require__(/*! ./WebSocketClient */ \"(ssr)/./node_modules/websocket/lib/WebSocketClient.js\"),\n    'router'       : __webpack_require__(/*! ./WebSocketRouter */ \"(ssr)/./node_modules/websocket/lib/WebSocketRouter.js\"),\n    'frame'        : __webpack_require__(/*! ./WebSocketFrame */ \"(ssr)/./node_modules/websocket/lib/WebSocketFrame.js\"),\n    'request'      : __webpack_require__(/*! ./WebSocketRequest */ \"(ssr)/./node_modules/websocket/lib/WebSocketRequest.js\"),\n    'connection'   : __webpack_require__(/*! ./WebSocketConnection */ \"(ssr)/./node_modules/websocket/lib/WebSocketConnection.js\"),\n    'w3cwebsocket' : __webpack_require__(/*! ./W3CWebSocket */ \"(ssr)/./node_modules/websocket/lib/W3CWebSocket.js\"),\n    'deprecation'  : __webpack_require__(/*! ./Deprecation */ \"(ssr)/./node_modules/websocket/lib/Deprecation.js\"),\n    'version'      : __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/websocket/lib/version.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi93ZWJzb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ2hELHFCQUFxQixtQkFBTyxDQUFDLGdGQUFtQjtBQUNoRCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsa0ZBQW9CO0FBQ2pELHFCQUFxQixtQkFBTyxDQUFDLHdGQUF1QjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsd0VBQWU7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsZ0VBQVc7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3dlYnNvY2tldC5qcz8yM2U3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICAgICdzZXJ2ZXInICAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRTZXJ2ZXInKSxcbiAgICAnY2xpZW50JyAgICAgICA6IHJlcXVpcmUoJy4vV2ViU29ja2V0Q2xpZW50JyksXG4gICAgJ3JvdXRlcicgICAgICAgOiByZXF1aXJlKCcuL1dlYlNvY2tldFJvdXRlcicpLFxuICAgICdmcmFtZScgICAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRGcmFtZScpLFxuICAgICdyZXF1ZXN0JyAgICAgIDogcmVxdWlyZSgnLi9XZWJTb2NrZXRSZXF1ZXN0JyksXG4gICAgJ2Nvbm5lY3Rpb24nICAgOiByZXF1aXJlKCcuL1dlYlNvY2tldENvbm5lY3Rpb24nKSxcbiAgICAndzNjd2Vic29ja2V0JyA6IHJlcXVpcmUoJy4vVzNDV2ViU29ja2V0JyksXG4gICAgJ2RlcHJlY2F0aW9uJyAgOiByZXF1aXJlKCcuL0RlcHJlY2F0aW9uJyksXG4gICAgJ3ZlcnNpb24nICAgICAgOiByZXF1aXJlKCcuL3ZlcnNpb24nKVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/lib/websocket.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUscUhBQW1DO0FBQzdDLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNLHFCQUFxQjtBQUMzQjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzPzI0NmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuICByZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0JylcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/debug/src/browser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/debug/src/debug.js":
/*!****************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/debug.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"(ssr)/./node_modules/websocket/node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxlQUFlO0FBQ2YsY0FBYztBQUNkLGVBQWU7QUFDZiwyR0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2IsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsYUFBYTtBQUNmLEVBQUUsYUFBYTs7QUFFZjtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9kZWJ1Zy5qcz9iNzE5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/debug/src/debug.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/debug/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/node.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDRIQUF3QztBQUMxQyxFQUFFO0FBQ0YsRUFBRSxzSEFBcUM7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcz8wMjU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIHByb2Nlc3MsIHdoaWNoIGlzIG5vZGUsIGJ1dCB3ZSBzaG91bGRcbiAqIHRyZWF0IGFzIGEgYnJvd3Nlci5cbiAqL1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/debug/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/debug/src/node.js":
/*!***************************************************************!*\
  !*** ./node_modules/websocket/node_modules/debug/src/node.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"(ssr)/./node_modules/websocket/node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = __webpack_require__(/*! fs */ \"fs\");\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = __webpack_require__(/*! net */ \"net\");\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFIQUFtQztBQUM3QyxZQUFZO0FBQ1osV0FBVztBQUNYLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMsSUFBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxjQUFJO0FBQzNCLDRDQUE0QyxrQkFBa0I7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsZ0JBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzPzI3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbNiwgMiwgMywgNCwgNSwgMV07XG5cbi8qKlxuICogQnVpbGQgdXAgdGhlIGRlZmF1bHQgYGluc3BlY3RPcHRzYCBvYmplY3QgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICpcbiAqICAgJCBERUJVR19DT0xPUlM9bm8gREVCVUdfREVQVEg9MTAgREVCVUdfU0hPV19ISURERU49ZW5hYmxlZCBub2RlIHNjcmlwdC5qc1xuICovXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAvLyBjYW1lbC1jYXNlXG4gIHZhciBwcm9wID0ga2V5XG4gICAgLnN1YnN0cmluZyg2KVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnJlcGxhY2UoL18oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBrKSB7IHJldHVybiBrLnRvVXBwZXJDYXNlKCkgfSk7XG5cbiAgLy8gY29lcmNlIHN0cmluZyB2YWx1ZSBpbnRvIEpTIHZhbHVlXG4gIHZhciB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuICBpZiAoL14oeWVzfG9ufHRydWV8ZW5hYmxlZCkkL2kudGVzdCh2YWwpKSB2YWwgPSB0cnVlO1xuICBlbHNlIGlmICgvXihub3xvZmZ8ZmFsc2V8ZGlzYWJsZWQpJC9pLnRlc3QodmFsKSkgdmFsID0gZmFsc2U7XG4gIGVsc2UgaWYgKHZhbCA9PT0gJ251bGwnKSB2YWwgPSBudWxsO1xuICBlbHNlIHZhbCA9IE51bWJlcih2YWwpO1xuXG4gIG9ialtwcm9wXSA9IHZhbDtcbiAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuLyoqXG4gKiBUaGUgZmlsZSBkZXNjcmlwdG9yIHRvIHdyaXRlIHRoZSBgZGVidWcoKWAgY2FsbHMgdG8uXG4gKiBTZXQgdGhlIGBERUJVR19GRGAgZW52IHZhcmlhYmxlIHRvIG92ZXJyaWRlIHdpdGggYW5vdGhlciB2YWx1ZS4gaS5lLjpcbiAqXG4gKiAgICQgREVCVUdfRkQ9MyBub2RlIHNjcmlwdC5qcyAzPmRlYnVnLmxvZ1xuICovXG5cbnZhciBmZCA9IHBhcnNlSW50KHByb2Nlc3MuZW52LkRFQlVHX0ZELCAxMCkgfHwgMjtcblxuaWYgKDEgIT09IGZkICYmIDIgIT09IGZkKSB7XG4gIHV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uKCl7fSwgJ2V4Y2VwdCBmb3Igc3RkZXJyKDIpIGFuZCBzdGRvdXQoMSksIGFueSBvdGhlciB1c2FnZSBvZiBERUJVR19GRCBpcyBkZXByZWNhdGVkLiBPdmVycmlkZSBkZWJ1Zy5sb2cgaWYgeW91IHdhbnQgdG8gdXNlIGEgZGlmZmVyZW50IGxvZyBmdW5jdGlvbiAoaHR0cHM6Ly9naXQuaW8vZGVidWdfZmQpJykoKVxufVxuXG52YXIgc3RyZWFtID0gMSA9PT0gZmQgPyBwcm9jZXNzLnN0ZG91dCA6XG4gICAgICAgICAgICAgMiA9PT0gZmQgPyBwcm9jZXNzLnN0ZGVyciA6XG4gICAgICAgICAgICAgY3JlYXRlV3JpdGFibGVTdGRpb1N0cmVhbShmZCk7XG5cbi8qKlxuICogSXMgc3Rkb3V0IGEgVFRZPyBDb2xvcmVkIG91dHB1dCBpcyBlbmFibGVkIHdoZW4gYHRydWVgLlxuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgcmV0dXJuICdjb2xvcnMnIGluIGV4cG9ydHMuaW5zcGVjdE9wdHNcbiAgICA/IEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpXG4gICAgOiB0dHkuaXNhdHR5KGZkKTtcbn1cblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cylcbiAgICAuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudHJpbSgpXG4gICAgfSkuam9pbignICcpO1xufTtcblxuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsb3dpbmcgbXVsdGlwbGUgbGluZXMgaWYgbmVlZGVkLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5PID0gZnVuY3Rpb24odikge1xuICB0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuICByZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcblxuLyoqXG4gKiBBZGRzIEFOU0kgY29sb3IgZXNjYXBlIGNvZGVzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLm5hbWVzcGFjZTtcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGlmICh1c2VDb2xvcnMpIHtcbiAgICB2YXIgYyA9IHRoaXMuY29sb3I7XG4gICAgdmFyIHByZWZpeCA9ICcgIFxcdTAwMWJbMycgKyBjICsgJzsxbScgKyBuYW1lICsgJyAnICsgJ1xcdTAwMWJbMG0nO1xuXG4gICAgYXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuICAgIGFyZ3MucHVzaCgnXFx1MDAxYlszJyArIGMgKyAnbSsnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgJ1xcdTAwMWJbMG0nKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzWzBdID0gbmV3IERhdGUoKS50b1VUQ1N0cmluZygpXG4gICAgICArICcgJyArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuICB9XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXQoKWAgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cyBhbmQgd3JpdGVzIHRvIGBzdHJlYW1gLlxuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgcmV0dXJuIHN0cmVhbS53cml0ZSh1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmd1bWVudHMpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgIC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuICAgIC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52LkRFQlVHID0gbmFtZXNwYWNlcztcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5ERUJVRztcbn1cblxuLyoqXG4gKiBDb3BpZWQgZnJvbSBgbm9kZS9zcmMvbm9kZS5qc2AuXG4gKlxuICogWFhYOiBJdCdzIGxhbWUgdGhhdCBub2RlIGRvZXNuJ3QgZXhwb3NlIHRoaXMgQVBJIG91dC1vZi10aGUtYm94LiBJdCBhbHNvXG4gKiByZWxpZXMgb24gdGhlIHVuZG9jdW1lbnRlZCBgdHR5X3dyYXAuZ3Vlc3NIYW5kbGVUeXBlKClgIHdoaWNoIGlzIGFsc28gbGFtZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVXcml0YWJsZVN0ZGlvU3RyZWFtIChmZCkge1xuICB2YXIgc3RyZWFtO1xuICB2YXIgdHR5X3dyYXAgPSBwcm9jZXNzLmJpbmRpbmcoJ3R0eV93cmFwJyk7XG5cbiAgLy8gTm90ZSBzdHJlYW0uX3R5cGUgaXMgdXNlZCBmb3IgdGVzdC1tb2R1bGUtbG9hZC1saXN0LmpzXG5cbiAgc3dpdGNoICh0dHlfd3JhcC5ndWVzc0hhbmRsZVR5cGUoZmQpKSB7XG4gICAgY2FzZSAnVFRZJzpcbiAgICAgIHN0cmVhbSA9IG5ldyB0dHkuV3JpdGVTdHJlYW0oZmQpO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ3R0eSc7XG5cbiAgICAgIC8vIEhhY2sgdG8gaGF2ZSBzdHJlYW0gbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgYWxpdmUuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzI2XG4gICAgICBpZiAoc3RyZWFtLl9oYW5kbGUgJiYgc3RyZWFtLl9oYW5kbGUudW5yZWYpIHtcbiAgICAgICAgc3RyZWFtLl9oYW5kbGUudW5yZWYoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRklMRSc6XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgc3RyZWFtID0gbmV3IGZzLlN5bmNXcml0ZVN0cmVhbShmZCwgeyBhdXRvQ2xvc2U6IGZhbHNlIH0pO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ2ZzJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnUElQRSc6XG4gICAgY2FzZSAnVENQJzpcbiAgICAgIHZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbiAgICAgIHN0cmVhbSA9IG5ldyBuZXQuU29ja2V0KHtcbiAgICAgICAgZmQ6IGZkLFxuICAgICAgICByZWFkYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgLy8gRklYTUUgU2hvdWxkIHByb2JhYmx5IGhhdmUgYW4gb3B0aW9uIGluIG5ldC5Tb2NrZXQgdG8gY3JlYXRlIGFcbiAgICAgIC8vIHN0cmVhbSBmcm9tIGFuIGV4aXN0aW5nIGZkIHdoaWNoIGlzIHdyaXRhYmxlIG9ubHkuIEJ1dCBmb3Igbm93XG4gICAgICAvLyB3ZSdsbCBqdXN0IGFkZCB0aGlzIGhhY2sgYW5kIHNldCB0aGUgYHJlYWRhYmxlYCBtZW1iZXIgdG8gZmFsc2UuXG4gICAgICAvLyBUZXN0OiAuL25vZGUgdGVzdC9maXh0dXJlcy9lY2hvLmpzIDwgL2V0Yy9wYXNzd2RcbiAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlYWQgPSBudWxsO1xuICAgICAgc3RyZWFtLl90eXBlID0gJ3BpcGUnO1xuXG4gICAgICAvLyBGSVhNRSBIYWNrIHRvIGhhdmUgc3RyZWFtIG5vdCBrZWVwIHRoZSBldmVudCBsb29wIGFsaXZlLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcyNlxuICAgICAgaWYgKHN0cmVhbS5faGFuZGxlICYmIHN0cmVhbS5faGFuZGxlLnVucmVmKSB7XG4gICAgICAgIHN0cmVhbS5faGFuZGxlLnVucmVmKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBQcm9iYWJseSBhbiBlcnJvciBvbiBpbiB1dl9ndWVzc19oYW5kbGUoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbXBsZW1lbnQgbWUuIFVua25vd24gc3RyZWFtIGZpbGUgdHlwZSEnKTtcbiAgfVxuXG4gIC8vIEZvciBzdXBwb3J0aW5nIGxlZ2FjeSBBUEkgd2UgcHV0IHRoZSBGRCBoZXJlLlxuICBzdHJlYW0uZmQgPSBmZDtcblxuICBzdHJlYW0uX2lzU3RkaW8gPSB0cnVlO1xuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbi8qKlxuICogSW5pdCBsb2dpYyBmb3IgYGRlYnVnYCBpbnN0YW5jZXMuXG4gKlxuICogQ3JlYXRlIGEgbmV3IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGluIGNhc2UgYHVzZUNvbG9yc2AgaXMgc2V0XG4gKiBkaWZmZXJlbnRseSBmb3IgYSBwYXJ0aWN1bGFyIGBkZWJ1Z2AgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gaW5pdCAoZGVidWcpIHtcbiAgZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuaW5zcGVjdE9wdHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYHByb2Nlc3MuZW52LkRFQlVHYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/debug/src/node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzPzRjYzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/node_modules/ms/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/vendor/FastBufferList.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/vendor/FastBufferList.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar bufferAllocUnsafe = (__webpack_require__(/*! ../lib/utils */ \"(ssr)/./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe);\n\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\n\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    \n    if (typeof(opts) == 'undefined') opts = {};\n    \n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    \n    var head = { next : null, buffer : null };\n    var last = { next : null, buffer : null };\n    \n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__('length', function () {\n        return length;\n    });\n    \n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    \n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function (buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        }\n        else {\n            last.next = { next : null, buffer : buf };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit('write', buf);\n        return true;\n    };\n    \n    self.end = function (buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    \n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function () {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    \n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function (fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        \n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        \n        var b = { buffer : firstBuf, next : head.next };\n        \n        while (b && b.buffer) {\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        \n        return self;\n    };\n    \n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function (start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        \n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (start < (ix + buffer.length) && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(0, ix - start),\n                    Math.max(0, start - ix),\n                    Math.min(buffer.length, end - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        \n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (sourceStart < (ix + buffer.length) && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(targetStart, targetStart + ix - sourceStart),\n                    Math.max(0, sourceStart - ix),\n                    Math.min(buffer.length, sourceEnd - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function (n) {\n        offset += n;\n        length -= n;\n        while (head.buffer && offset >= head.buffer.length) {\n            offset -= head.buffer.length;\n            head = head.next\n                ? head.next\n                : { buffer : null, next : null }\n            ;\n        }\n        if (head.buffer === null) last = { next : null, buffer : null };\n        self.emit('advance', n);\n        return self;\n    };\n    \n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function (n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== 'number') {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = '';\n            self.forEach(function (buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(\n                    encoding, 0, Math.min(n,buffer.length)\n                );\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    \n    // The entire concatenated buffer as a string.\n    self.toString = function () {\n        return self.take('binary');\n    };\n}\n(__webpack_require__(/*! util */ \"util\").inherits)(BufferList, EventEmitter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L3ZlbmRvci9GYXN0QnVmZmVyTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsb0RBQXdCO0FBQ3JDLG1CQUFtQiwwREFBOEI7QUFDakQsd0JBQXdCLDBHQUF5Qzs7QUFFakU7QUFDQSx5QkFBeUIsZUFBZTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWJwcm9kaWdpZXMtY3lwcmVzcy8uL25vZGVfbW9kdWxlcy93ZWJzb2NrZXQvdmVuZG9yL0Zhc3RCdWZmZXJMaXN0LmpzP2Y0ZjQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIHdhcyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svbm9kZS1idWZmZXJsaXN0XG4vLyBhbmQgbW9kaWZpZWQgdG8gYmUgYWJsZSB0byBjb3B5IGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmxpc3QgZGlyZWN0bHkgaW50b1xuLy8gYSBwcmUtZXhpc3RpbmcgZml4ZWQtc2l6ZSBidWZmZXIgd2l0aG91dCBhbiBhZGRpdGlvbmFsIG1lbW9yeSBhbGxvY2F0aW9uLlxuXG4vLyBidWZmZXJsaXN0LmpzXG4vLyBUcmVhdCBhIGxpbmtlZCBsaXN0IG9mIGJ1ZmZlcnMgYXMgYSBzaW5nbGUgdmFyaWFibGUtc2l6ZSBidWZmZXIuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBidWZmZXJBbGxvY1Vuc2FmZSA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpLmJ1ZmZlckFsbG9jVW5zYWZlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3Q7XG5tb2R1bGUuZXhwb3J0cy5CdWZmZXJMaXN0ID0gQnVmZmVyTGlzdDsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuZnVuY3Rpb24gQnVmZmVyTGlzdChvcHRzKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QpKSByZXR1cm4gbmV3IEJ1ZmZlckxpc3Qob3B0cyk7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIGlmICh0eXBlb2Yob3B0cykgPT0gJ3VuZGVmaW5lZCcpIG9wdHMgPSB7fTtcbiAgICBcbiAgICAvLyBkZWZhdWx0IGVuY29kaW5nIHRvIHVzZSBmb3IgdGFrZSgpLiBMZWF2aW5nIGFzICd1bmRlZmluZWQnXG4gICAgLy8gbWFrZXMgdGFrZSgpIHJldHVybiBhIEJ1ZmZlciBpbnN0ZWFkLlxuICAgIHNlbGYuZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nO1xuICAgIFxuICAgIHZhciBoZWFkID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogbnVsbCB9O1xuICAgIHZhciBsYXN0ID0geyBuZXh0IDogbnVsbCwgYnVmZmVyIDogbnVsbCB9O1xuICAgIFxuICAgIC8vIGxlbmd0aCBjYW4gZ2V0IG5lZ2F0aXZlIHdoZW4gYWR2YW5jZWQgcGFzdCB0aGUgZW5kXG4gICAgLy8gYW5kIHRoaXMgaXMgdGhlIGRlc2lyZWQgYmVoYXZpb3JcbiAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICBzZWxmLl9fZGVmaW5lR2V0dGVyX18oJ2xlbmd0aCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBrZWVwIGFuIG9mZnNldCBvZiB0aGUgaGVhZCB0byBkZWNpZGUgd2hlbiB0byBoZWFkID0gaGVhZC5uZXh0XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgXG4gICAgLy8gV3JpdGUgdG8gdGhlIGJ1ZmZlcmxpc3QuIEVtaXRzICd3cml0ZScuIEFsd2F5cyByZXR1cm5zIHRydWUuXG4gICAgc2VsZi53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikge1xuICAgICAgICAgICAgaGVhZC5idWZmZXIgPSBidWY7XG4gICAgICAgICAgICBsYXN0ID0gaGVhZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QubmV4dCA9IHsgbmV4dCA6IG51bGwsIGJ1ZmZlciA6IGJ1ZiB9O1xuICAgICAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgc2VsZi5lbWl0KCd3cml0ZScsIGJ1Zik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgc2VsZi5lbmQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmKSkgc2VsZi53cml0ZShidWYpO1xuICAgIH07XG4gICAgXG4gICAgLy8gUHVzaCBidWZmZXJzIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZCBsaXN0LiAoZGVwcmVjYXRlZClcbiAgICAvLyBSZXR1cm4gdGhpcyAoc2VsZikuXG4gICAgc2VsZi5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLmNvbmNhdC5hcHBseShbXSwgYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy5mb3JFYWNoKHNlbGYud3JpdGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIEZvciBlYWNoIGJ1ZmZlciwgcGVyZm9ybSBzb21lIGFjdGlvbi5cbiAgICAvLyBJZiBmbidzIHJlc3VsdCBpcyBhIHRydWUgdmFsdWUsIGN1dCBvdXQgZWFybHkuXG4gICAgLy8gUmV0dXJucyB0aGlzIChzZWxmKS5cbiAgICBzZWxmLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGhlYWQuYnVmZmVyLmxlbmd0aCAtIG9mZnNldCA8PSAwKSByZXR1cm4gc2VsZjtcbiAgICAgICAgdmFyIGZpcnN0QnVmID0gaGVhZC5idWZmZXIuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBiID0geyBidWZmZXIgOiBmaXJzdEJ1ZiwgbmV4dCA6IGhlYWQubmV4dCB9O1xuICAgICAgICBcbiAgICAgICAgd2hpbGUgKGIgJiYgYi5idWZmZXIpIHtcbiAgICAgICAgICAgIHZhciByID0gZm4oYi5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKHIpIGJyZWFrO1xuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzaW5nbGUgQnVmZmVyIG91dCBvZiBhbGwgdGhlIGNodW5rcyBvciBzb21lIHN1YnNldCBzcGVjaWZpZWQgYnlcbiAgICAvLyBzdGFydCBhbmQgb25lLXBhc3QgdGhlIGVuZCAobGlrZSBzbGljZSkgaW4gYnl0ZXMuXG4gICAgc2VsZi5qb2luID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIGJ1ZmZlckFsbG9jVW5zYWZlKDApO1xuICAgICAgICBpZiAoc3RhcnQgPT0gdW5kZWZpbmVkKSBzdGFydCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT0gdW5kZWZpbmVkKSBlbmQgPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgXG4gICAgICAgIHZhciBiaWcgPSBidWZmZXJBbGxvY1Vuc2FmZShlbmQgLSBzdGFydCk7XG4gICAgICAgIHZhciBpeCA9IDA7XG4gICAgICAgIHNlbGYuZm9yRWFjaChmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAoaXggKyBidWZmZXIubGVuZ3RoKSAmJiBpeCA8IGVuZCkge1xuICAgICAgICAgICAgICAgIC8vIGF0IGxlYXN0IHBhcnRpYWxseSBjb250YWluZWQgaW4gdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgYnVmZmVyLmNvcHkoXG4gICAgICAgICAgICAgICAgICAgIGJpZyxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgaXggLSBzdGFydCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDAsIHN0YXJ0IC0gaXgpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihidWZmZXIubGVuZ3RoLCBlbmQgLSBpeClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpeCA+IGVuZCkgcmV0dXJuIHRydWU7IC8vIHN0b3AgcHJvY2Vzc2luZyBwYXN0IGVuZFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBiaWc7XG4gICAgfTtcbiAgICBcbiAgICBzZWxmLmpvaW5JbnRvID0gZnVuY3Rpb24gKHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgICAgICAgaWYgKCFoZWFkLmJ1ZmZlcikgcmV0dXJuIG5ldyBidWZmZXJBbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgaWYgKHNvdXJjZVN0YXJ0ID09IHVuZGVmaW5lZCkgc291cmNlU3RhcnQgPSAwO1xuICAgICAgICBpZiAoc291cmNlRW5kID09IHVuZGVmaW5lZCkgc291cmNlRW5kID0gc2VsZi5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICB2YXIgYmlnID0gdGFyZ2V0QnVmZmVyO1xuICAgICAgICBpZiAoYmlnLmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgc291cmNlRW5kIC0gc291cmNlU3RhcnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluc3VmZmljaWVudCBzcGFjZSBhdmFpbGFibGUgaW4gdGFyZ2V0IEJ1ZmZlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl4ID0gMDtcbiAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VTdGFydCA8IChpeCArIGJ1ZmZlci5sZW5ndGgpICYmIGl4IDwgc291cmNlRW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gYXQgbGVhc3QgcGFydGlhbGx5IGNvbnRhaW5lZCBpbiB0aGUgcmFuZ2VcbiAgICAgICAgICAgICAgICBidWZmZXIuY29weShcbiAgICAgICAgICAgICAgICAgICAgYmlnLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCh0YXJnZXRTdGFydCwgdGFyZ2V0U3RhcnQgKyBpeCAtIHNvdXJjZVN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCwgc291cmNlU3RhcnQgLSBpeCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJ1ZmZlci5sZW5ndGgsIHNvdXJjZUVuZCAtIGl4KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpeCArPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGl4ID4gc291cmNlRW5kKSByZXR1cm4gdHJ1ZTsgLy8gc3RvcCBwcm9jZXNzaW5nIHBhc3QgZW5kXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGJpZztcbiAgICB9O1xuICAgIFxuICAgIC8vIEFkdmFuY2UgdGhlIGJ1ZmZlciBzdHJlYW0gYnkgbiBieXRlcy5cbiAgICAvLyBJZiBuIHRoZSBhZ2dyZWdhdGUgYWR2YW5jZSBvZmZzZXQgcGFzc2VzIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBsaXN0LFxuICAgIC8vIG9wZXJhdGlvbnMgc3VjaCBhcyAudGFrZSgpIHdpbGwgcmV0dXJuIGVtcHR5IHN0cmluZ3MgdW50aWwgZW5vdWdoIGRhdGEgaXNcbiAgICAvLyBwdXNoZWQuXG4gICAgLy8gUmV0dXJucyB0aGlzIChzZWxmKS5cbiAgICBzZWxmLmFkdmFuY2UgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgbGVuZ3RoIC09IG47XG4gICAgICAgIHdoaWxlIChoZWFkLmJ1ZmZlciAmJiBvZmZzZXQgPj0gaGVhZC5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBvZmZzZXQgLT0gaGVhZC5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaGVhZCA9IGhlYWQubmV4dFxuICAgICAgICAgICAgICAgID8gaGVhZC5uZXh0XG4gICAgICAgICAgICAgICAgOiB7IGJ1ZmZlciA6IG51bGwsIG5leHQgOiBudWxsIH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZC5idWZmZXIgPT09IG51bGwpIGxhc3QgPSB7IG5leHQgOiBudWxsLCBidWZmZXIgOiBudWxsIH07XG4gICAgICAgIHNlbGYuZW1pdCgnYWR2YW5jZScsIG4pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIFxuICAgIC8vIFRha2UgbiBieXRlcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYnVmZmVycy5cbiAgICAvLyBSZXR1cm5zIGEgc3RyaW5nLlxuICAgIC8vIElmIHRoZXJlIGFyZSBsZXNzIHRoYW4gbiBieXRlcyBpbiBhbGwgdGhlIGJ1ZmZlcnMgb3IgbiBpcyB1bmRlZmluZWQsXG4gICAgLy8gcmV0dXJucyB0aGUgZW50aXJlIGNvbmNhdGVuYXRlZCBidWZmZXIgc3RyaW5nLlxuICAgIHNlbGYudGFrZSA9IGZ1bmN0aW9uIChuLCBlbmNvZGluZykge1xuICAgICAgICBpZiAobiA9PSB1bmRlZmluZWQpIG4gPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlbmNvZGluZyA9IG47XG4gICAgICAgICAgICBuID0gc2VsZi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBoZWFkO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHNlbGYuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgICAgdmFyIGFjYyA9ICcnO1xuICAgICAgICAgICAgc2VsZi5mb3JFYWNoKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobiA8PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhY2MgKz0gYnVmZmVyLnRvU3RyaW5nKFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGluZywgMCwgTWF0aC5taW4obixidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbiAtPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gJ2VuY29kaW5nJyBpcyBzcGVjaWZpZWQsIHRoZW4gcmV0dXJuIGEgQnVmZmVyLlxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuam9pbigwLCBuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gVGhlIGVudGlyZSBjb25jYXRlbmF0ZWQgYnVmZmVyIGFzIGEgc3RyaW5nLlxuICAgIHNlbGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRha2UoJ2JpbmFyeScpO1xuICAgIH07XG59XG5yZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoQnVmZmVyTGlzdCwgRXZlbnRFbWl0dGVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/websocket/vendor/FastBufferList.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.34","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ })

};
;